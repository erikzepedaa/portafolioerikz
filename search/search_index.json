{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Veh\u00edculo Controlado por Bluetooth con Motores DC","text":""},{"location":"#proposito","title":"Proposito","text":"<p>Este proyecto consisti\u00f3 en el dise\u00f1o y construcci\u00f3n de un veh\u00edculo a control remoto, utilizando motores de corriente directa (DC), un puente H para el control de direcci\u00f3n, y un microcontrolador ESP32 para la comunicaci\u00f3n v\u00eda Bluetooth. El objetivo principal fue aplicar conocimientos b\u00e1sicos de electr\u00f3nica, mec\u00e1nica y programaci\u00f3n para competir en una din\u00e1mica de rob\u00f3tica.</p>"},{"location":"#metas-del-proyecto","title":"Metas del Proyecto","text":"<p>Meta General: Desarrollar un prototipo funcional de un coche a control remoto que pueda participar en una competencia de rob\u00f3tica, demostrando habilidades de dise\u00f1o, integraci\u00f3n de sistemas y trabajo en equipo. Metas Espec\u00edficas:</p> <p>Implementar un sistema de control que permita maniobrar el veh\u00edculo con precisi\u00f3n y velocidad. Dise\u00f1ar una pala frontal que facilite la interacci\u00f3n con objetos (como pelotas) durante la competencia. Optimizar el rendimiento del coche para lograr una ventaja competitiva en el juego.</p>"},{"location":"#alcance-del-proyecto","title":"Alcance del Proyecto","text":"<p>El proyecto abarc\u00f3 desde la conceptualizaci\u00f3n del dise\u00f1o hasta la implementaci\u00f3n completa del sistema electr\u00f3nico y mec\u00e1nico. Se trabaj\u00f3 con materiales accesibles y se estableci\u00f3 un l\u00edmite de dos semanas para su desarrollo. Incluye: - Dise\u00f1o estructural del veh\u00edculo - Integraci\u00f3n de componentes electr\u00f3nicos - Programaci\u00f3n del sistema de control - Pruebas funcionales previas a la competencia</p>"},{"location":"#proceso-de-trabajo","title":"Proceso de Trabajo","text":""},{"location":"#organizacion-del-equipo","title":"Organizaci\u00f3n del Equipo","text":"<p>El equipo se dividi\u00f3 en dos \u00e1reas principales: dise\u00f1o mec\u00e1nico y desarrollo electr\u00f3nico. Mientras algunos miembros se encargaron de la estructura del coche, otros se enfocaron en la programaci\u00f3n y conexiones.</p>"},{"location":"#materiales-utilizados","title":"Materiales Utilizados","text":"<ul> <li>2 motores DC</li> <li>Puente H</li> <li>ESP32</li> <li>Protoboard</li> <li>Jumpers</li> <li>LED</li> <li>Bater\u00eda de 9V</li> <li>MDF para la base</li> <li>PLA para impresi\u00f3n 3D de la pala frontal</li> </ul>"},{"location":"#tecnologias-utilizadas","title":"Tecnolog\u00edas Utilizadas","text":"<ul> <li>Lenguajes: <code>Python</code>, <code>C++</code></li> <li>Hardware: <code>ESP32</code>, <code>Arduino</code></li> <li>Software: <code>SolidWorks</code>, <code>PSeInt</code></li> <li>Otros: <code>CircuitVerse</code> </li> </ul>"},{"location":"#sistema-electronico","title":"Sistema Electr\u00f3nico","text":"<p>Se conectaron los motores al puente H, asegurando una correcta polaridad y conexi\u00f3n a tierra. Los pines IN1 a IN4 se configuraron para controlar la direcci\u00f3n de giro de los motores. La ESP32 se integr\u00f3 como unidad de control, con especial atenci\u00f3n a la asignaci\u00f3n de pines y la protecci\u00f3n contra cortocircuitos.</p>"},{"location":"#programacion","title":"Programaci\u00f3n","text":"<p>Se desarroll\u00f3 un programa en Arduino IDE que permite controlar el coche mediante una aplicaci\u00f3n Bluetooth. Las funciones principales incluyeron:</p> <ul> <li>Avanzar</li> <li>Retroceder</li> <li>Girar a la izquierda/derecha</li> <li>Detenerse</li> <li>Ajustar velocidad mediante PWM</li> </ul> <p>La l\u00f3gica de movimiento se bas\u00f3 en la manipulaci\u00f3n de los motores: por ejemplo, para girar, se detiene una rueda mientras la otra sigue girando. El codigo para controlar el coche se encuentr al final del articulo.</p>"},{"location":"#resultados-y-observaciones","title":"Resultados y Observaciones","text":"<p>Antes de la competencia, el coche mostr\u00f3 un buen desempe\u00f1o: respond\u00eda a los comandos, la pala funcionaba correctamente y el dise\u00f1o era estable. Sin embargo, durante el evento surgieron algunos inconvenientes:</p> <p>Uno de los motores se desprendi\u00f3 tras un choque con una silla. El control Bluetooth presentaba cierto retraso en la respuesta. Los movimientos eran algo bruscos, lo que dificultaba la precisi\u00f3n.</p> <p>A pesar de estos detalles, el coche cumpli\u00f3 con los objetivos t\u00e9cnicos del proyecto.</p>"},{"location":"#evidencias","title":"Evidencias","text":"<p>Ver la primera prueba del coche en YouTube</p>"},{"location":"#un-poco-del-partido","title":"Un poco del partido","text":"<p>Ver un poco de la competencia en Youtube</p>"},{"location":"#reflexiones-finales","title":"Reflexiones Finales","text":"<p>El proyecto fue una excelente oportunidad para aplicar conocimientos te\u00f3ricos en un entorno pr\u00e1ctico. Se logr\u00f3 integrar electr\u00f3nica, mec\u00e1nica y programaci\u00f3n en un sistema funcional. Algunas \u00e1reas de mejora identificadas fueron:</p> <p>Realizar m\u00e1s pruebas antes de la competencia Mejorar el montaje de los motores Optimizar el control desde la app</p> <p>Esta experiencia reforz\u00f3 la importancia de la planificaci\u00f3n, el trabajo colaborativo y la iteraci\u00f3n constante para lograr un producto funcional y competitivo.</p>"},{"location":"#codigo-para-controlar-el-coche","title":"Codigo para controlar el coche","text":"<pre><code>#include \"BluetoothSerial.h\"\n\nBluetoothSerial SerialBT;\n\n\n// Pines del puente H\n\nconst int IN1 = 12; // Motor izquierdo\n\nconst int IN2 = 11;\n\nconst int ENA = 13;\n\nconst int IN3 = 10; // Motor derecho\n\nconst int IN4 = 9;\n\nconst int ENB = 7;\n\nint valSpeed = 255;\n\n\nvoid setup() {\n\n  Serial.begin(115200);\n\n  SerialBT.begin(\"CarroESP32\"); // Nombre del dispositivo Bluetooth\n\n  pinMode(IN1, OUTPUT);\n\n  pinMode(IN2, OUTPUT);\n\n  pinMode(ENA, OUTPUT);\n\n  pinMode(IN3, OUTPUT);\n\n  pinMode(IN4, OUTPUT);\n\n  pinMode(ENB, OUTPUT);\n\n  stopMotors();\n\n}\n\n\nvoid loop() {\n\n  if (SerialBT.available()) {\n\n    char command = SerialBT.read();\n\n    Serial.println(command);\n\n    switch (command) {\n\n      case 'F': forward(); break;\n\n      case 'B': backward(); break;\n\n      case 'L': turnLeft(); break;\n\n      case 'R': turnRight(); break;\n\n      case 'S': stopMotors(); break;\n\n      case '0': setSpeed(0); break;\n\n      case '1': setSpeed(25); break;\n\n      case '2': setSpeed(50); break;\n\n      case '3': setSpeed(75); break;\n\n      case '4': setSpeed(100); break;\n\n      case '5': setSpeed(125); break;\n\n      case '6': setSpeed(150); break;\n\n      case '7': setSpeed(175); break;\n\n      case '8': setSpeed(200); break;\n\n      case '9': setSpeed(255); break;\n\n    }\n\n  }\n\n}\n\n\nvoid forward() {\n\n  analogWrite(ENA, valSpeed);\n\n  analogWrite(ENB, valSpeed);\n\n  digitalWrite(IN1, HIGH);\n\n  digitalWrite(IN2, LOW);\n\n  digitalWrite(IN3, HIGH);\n\n  digitalWrite(IN4, LOW);\n\n}\n\n\nvoid backward() {\n\n  analogWrite(ENA, valSpeed);\n\n  analogWrite(ENB, valSpeed);\n\n  digitalWrite(IN1, LOW);\n\n  digitalWrite(IN2, HIGH);\n\n  digitalWrite(IN3, LOW);\n\n  digitalWrite(IN4, HIGH);\n\n}\n\n\nvoid turnLeft() {\n\n  analogWrite(ENA, valSpeed / 2);\n\n  analogWrite(ENB, valSpeed);\n\n  digitalWrite(IN1, HIGH);\n\n  digitalWrite(IN2, LOW);\n\n  digitalWrite(IN3, HIGH);\n\n  digitalWrite(IN4, LOW);\n\n}\n\n\nvoid turnRight() {\n\n  analogWrite(ENA, valSpeed);\n\n  analogWrite(ENB, valSpeed / 2);\n\n  digitalWrite(IN1, HIGH);\n\n  digitalWrite(IN2, LOW);\n\n  digitalWrite(IN3, HIGH);\n\n  digitalWrite(IN4, LOW);\n\n}\n\n\nvoid stopMotors() {\n\n  analogWrite(ENA, 0);\n\n  analogWrite(ENB, 0);\n\n  digitalWrite(IN1, LOW);\n\n  digitalWrite(IN2, LOW);\n\n  digitalWrite(IN3, LOW);\n\n  digitalWrite(IN4, LOW);\n\n}\n\n\nvoid setSpeed(int val) {\n\n  valSpeed = val;\n\n}\n</code></pre>"},{"location":"Trabajo%203/","title":"Control de Giro, Velocidad y Posici\u00f3n con ESP32","text":""},{"location":"Trabajo%203/#proposito","title":"Proposito","text":"<p>Explorar el control de motores mediante el ESP32, aplicando t\u00e9cnicas de cambio de giro, variaci\u00f3n de velocidad con PWM y posicionamiento de servo motores.</p>"},{"location":"Trabajo%203/#meta-de-la-practica","title":"Meta de la practica","text":"<p>Comprender c\u00f3mo controlar motores DC y servos utilizando programaci\u00f3n en ESP32, aplicando conceptos de l\u00f3gica digital, modulaci\u00f3n por ancho de pulso (PWM) y mapeo de valores para posicionamiento.</p>"},{"location":"Trabajo%203/#organizacion-del-equipo","title":"Organizaci\u00f3n del Equipo","text":"<p>El equipo se dividi\u00f3 en dos \u00e1reas principales: desarrollo del codigo de programacion y desarrollo electr\u00f3nico.</p>"},{"location":"Trabajo%203/#materiales-utilizados","title":"Materiales Utilizados","text":"<ul> <li>ESP32</li> <li>Motor DC</li> <li>Servo motor</li> <li>Protoboard</li> <li>Cables de conexi\u00f3n (jumpers)</li> <li>Fuente de alimentaci\u00f3n</li> <li>Cable USB para cargar el programa</li> </ul>"},{"location":"Trabajo%203/#tecnologias-utilizadas","title":"Tecnolog\u00edas Utilizadas","text":"<ul> <li>Lenguajes: <code>Python</code></li> <li>Hardware: <code>ESP32</code>, <code>Arduino</code></li> <li>Software: <code>ARDUINO IDE</code> </li> </ul>"},{"location":"Trabajo%203/#sistema-electronico","title":"Sistema Electr\u00f3nico","text":"<p>Cambio de giro del motor DC: Se conectaron dos pines digitales al motor, alternando su estado para cambiar la direcci\u00f3n de giro (adelante y atr\u00e1s).</p> <p>Control de velocidad del motor DC: Se utiliz\u00f3 un pin PWM configurado para incrementar la velocidad del motor.</p> <p>Control de posici\u00f3n de un servo motor: Se configur\u00f3 un canal PWM con frecuencia de 50 Hz y resoluci\u00f3n de 12 bits. Se us\u00f3 la funci\u00f3n map() para convertir grados (0\u00b0 a 180\u00b0) en valores de duty cycle entre 205 y 410, que corresponden al rango de operaci\u00f3n del servo.</p>"},{"location":"Trabajo%203/#programacion","title":"Programaci\u00f3n","text":"<p>Cambio de giro: alterna los pines in1 e in2 para cambiar la direcci\u00f3n del motor. Velocidad progresiva: usa ledcWrite() para aumentar gradualmente la velocidad del motor en pasos del 20%. Servo motor: utiliza PWM de 12 bits para mover el servo a posiciones espec\u00edficas (0\u00b0, 90\u00b0, 180\u00b0), mostrando los valores en el monitor serial.</p>"},{"location":"Trabajo%203/#resultados-y-observaciones","title":"Resultados y Observaciones","text":"<p>El motor DC respondi\u00f3 correctamente al cambio de giro, alternando entre avance y retroceso. El control de velocidad fue progresivo y estable, mostrando c\u00f3mo el PWM puede modificar la potencia entregada al motor. El servo motor se posicion\u00f3 con precisi\u00f3n en los \u00e1ngulos programados, y los valores de duty cycle se reflejaron correctamente en el monitor serial. No se presentaron errores de conexi\u00f3n ni fallas en la ejecuci\u00f3n de los c\u00f3digos.</p>"},{"location":"Trabajo%203/#evidencias","title":"Evidencias","text":"<p>Ver en YouTube</p>"},{"location":"Trabajo%203/#reflexiones-finales","title":"Reflexiones Finales","text":"<p>Esta pr\u00e1ctica permiti\u00f3 comprender tres aspectos fundamentales del control de motores con ESP32: direcci\u00f3n, velocidad y posici\u00f3n. Se reforz\u00f3 el uso de PWM en diferentes resoluciones y frecuencias, y se evidenci\u00f3 c\u00f3mo la programaci\u00f3n puede traducirse en movimientos f\u00edsicos precisos. Adem\u00e1s, se aprendi\u00f3 a mapear valores para controlar servos, y se observ\u00f3 la importancia de los retardos (delay) para estabilizar los cambios.</p>"},{"location":"Trabajo%203/#codigo-direccion-basica","title":"Codigo Direccion Basica","text":"<pre><code>/*Control de 1 solo motor*/\n#define in1 27\n#define in2 14\n\nvoid setup() {\n  /*Declarar Pines Como salida*/\n  pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n}\n\nvoid loop() {\n  /*ADELANTE*/\n  digitalWrite(in1, 0);\n  digitalWrite(in2, 1);\n  delay(1000);\n  /*ALTO*/\n  digitalWrite(in1, 0);\n  digitalWrite(in2, 0);\n  delay(1000);\n  /*ATRAS*/\n  digitalWrite(in1, 1);\n  digitalWrite(in2, 0);\n  delay(1000);\n  /*ALTO*/\n  digitalWrite(in1, 0);\n  digitalWrite(in2, 0);\n  delay(1000);\n}\n</code></pre>"},{"location":"Trabajo%203/#codigo-control-de-velocidad","title":"Codigo Control de velocidad","text":"<pre><code>/*Control de 1 solo motor*/\n#define in1 27\n#define in2 14\n\nvoid setup() {\n  /*Declarar Pines Como salida*/\n  pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n}\n\nvoid loop() {\n  /*ADELANTE*/\n  digitalWrite(in1, 0);\n  digitalWrite(in2, 1);\n  delay(1000);\n  /*ALTO*/\n  digitalWrite(in1, 0);\n  digitalWrite(in2, 0);\n  delay(1000);\n  /*ATRAS*/\n  digitalWrite(in1, 1);\n  digitalWrite(in2, 0);\n  delay(1000);\n  /*ALTO*/\n  digitalWrite(in1, 0);\n  digitalWrite(in2, 0);\n  delay(1000);\n}\n</code></pre>"},{"location":"Trabajo%203/#codigo-control-de-servo","title":"Codigo Control de Servo","text":"<pre><code>/*Control de 1 solo motor*/\n#define pwm 12 //Definicion de pin de Velocidad\nint duty = 0;\nint grados = 0;\nvoid setup() {\n  /*Declarar Pines Como salida*/\n  pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n  /*Configuracion de pin PWM \n    - Se conecta al pin 12(pwm)\n    - Frecuencia de 50hz\n    - Resolucion de 12 bit (0-4096)\n    - Canal 0\n  */\n  ledcAttachChannel(pwm, 50, 12, 0);\n  Serial.begin(115200);\n}\n\nvoid loop() { \n  /*\n  Servo trabaja del ~5% al ~10% del total\n  ~5% - 0\u00b0\n  ~10% - 180\u00b0\n  5% de 4096 = 204.8\n  10% de 4096 = 409.6\n  */\n  grados=0;\n  duty= map(grados, 0, 180, 205, 410);\n  Serial.print(\"Pos: \");\n  Serial.println(duty);\n  ledcWrite(pwm, duty);\n  delay(1000);\n  grados=90;\n  duty= map(grados, 0, 180, 205, 410);\n  Serial.print(\"Pos: \");\n  Serial.println(duty);\n  ledcWrite(pwm, duty);\n  delay(1000);\n  grados=180;\n  duty= map(grados, 0, 180, 205, 410);\n  Serial.print(\"Pos: \");\n  Serial.println(duty);\n  ledcWrite(pwm, duty);\n  delay(1000);\n}\n</code></pre>"},{"location":"Trabajo2/","title":"Comunicaci\u00f3n Bluetooth entre ESP32 y Celular","text":""},{"location":"Trabajo2/#proposito","title":"Proposito","text":"<p>Establecer una comunicaci\u00f3n inal\u00e1mbrica entre un ESP32 y un tel\u00e9fono celular mediante Bluetooth, para enviar mensajes desde la app de Arduino y visualizar el texto recibido en el monitor serial de la computadora.</p>"},{"location":"Trabajo2/#meta-de-la-practica","title":"Meta de la practica","text":"<p>Establecer una comunicaci\u00f3n inal\u00e1mbrica entre el ESP32 y un celular mediante Bluetooth, para recibir mensajes escritos desde una app m\u00f3vil y mostrarlos en el monitor serial de la computadora.</p>"},{"location":"Trabajo2/#organizacion-del-equipo","title":"Organizaci\u00f3n del Equipo","text":"<p>El equipo se dividi\u00f3 en dos \u00e1reas principales: desarrollo del codigo de programacion y desarrollo electr\u00f3nico.</p>"},{"location":"Trabajo2/#materiales-utilizados","title":"Materiales Utilizados","text":"<ul> <li>ESP32</li> <li>Protoboard</li> <li>Cables de conexi\u00f3n (jumpers)</li> <li>Cable USB para cargar el programa</li> <li>Aplicaci\u00f3n Arduino Bluetooth Controller (en celular Android)</li> <li>Computadora con Arduino IDE</li> </ul>"},{"location":"Trabajo2/#tecnologias-utilizadas","title":"Tecnolog\u00edas Utilizadas","text":"<ul> <li>Lenguajes: <code>Python</code></li> <li>Hardware: <code>ESP32</code>, <code>Arduino</code></li> <li>Software: <code>ARDUINO IDE</code> </li> </ul>"},{"location":"Trabajo2/#sistema-electronico","title":"Sistema Electr\u00f3nico","text":"<p>El ESP32 se conect\u00f3 a la computadora mediante USB. No se utilizaron componentes externos como sensores o actuadores, ya que el enfoque fue exclusivamente en la comunicaci\u00f3n serial por Bluetooth. El ESP32 se configur\u00f3 como servidor Bluetooth para que el celular pudiera detectarlo y conectarse.</p>"},{"location":"Trabajo2/#programacion","title":"Programaci\u00f3n","text":"<p>El c\u00f3digo desarrollado en esta pr\u00e1ctica permite establecer una comunicaci\u00f3n inal\u00e1mbrica entre un ESP32 y un tel\u00e9fono celular mediante Bluetooth. El objetivo es que los mensajes escritos desde la app del celular se reciban en el ESP32 y se muestren en el monitor serial de la computadora.</p> <p>Primero, se incluye la librer\u00eda BluetoothSerial.h, que es necesaria para habilitar la comunicaci\u00f3n Bluetooth en el ESP32.  Luego, se crea un objeto llamado SerialBT, el cual se encargar\u00e1 de manejar la conexi\u00f3n Bluetooth.</p> <p>En la funci\u00f3n setup(), se inicializa la comunicaci\u00f3n serial con la computadora usando Serial.begin(115200), lo que permite visualizar los datos en el monitor serial del Arduino IDE. </p> <p>Despu\u00e9s, se inicia el Bluetooth con SerialBT.begin(\"ESP32A\u00d1\"), donde \"ESP32A\u00d1\" es el nombre que aparecer\u00e1 en el celular al buscar dispositivos Bluetooth. Finalmente, se imprime un mensaje indicando que el Bluetooth est\u00e1 listo para recibir conexiones.</p> <p>En la funci\u00f3n loop(), el programa verifica constantemente si hay datos disponibles desde el celular con SerialBT.available(). </p> <p>Si se detecta un mensaje, se lee con SerialBT.readString() y se muestra en el monitor serial usando Serial.println(). </p> <p>Esto permite ver en tiempo real lo que se escribe en la app del celular directamente en la pantalla de la computadora. Se incluye un peque\u00f1o retraso de 1 segundo (delay(1000)) para evitar que el ciclo se ejecute demasiado r\u00e1pido.</p> <p>Este c\u00f3digo demuestra c\u00f3mo se puede usar el ESP32 como receptor Bluetooth para recibir texto desde un dispositivo m\u00f3vil y visualizarlo en la computadora, lo cual es \u00fatil para proyectos de comunicaci\u00f3n, monitoreo o control remoto.</p>"},{"location":"Trabajo2/#resultados-y-observaciones","title":"Resultados y Observaciones","text":"<p>La conexi\u00f3n Bluetooth fue exitosa y estable. Los mensajes escritos desde el celular se reflejaban correctamente en el monitor serial. El ESP32 respondi\u00f3 de forma inmediata a los datos recibidos. No se presentaron errores de transmisi\u00f3n ni desconexiones durante la prueba.</p>"},{"location":"Trabajo2/#evidencias","title":"Evidencias","text":"<p>Ver en YouTube</p>"},{"location":"Trabajo2/#reflexiones-finales","title":"Reflexiones Finales","text":"<p>Esta pr\u00e1ctica permiti\u00f3 entender c\u00f3mo se establece una comunicaci\u00f3n serial inal\u00e1mbrica entre un microcontrolador y un dispositivo m\u00f3vil. Se reforz\u00f3 el uso de librer\u00edas espec\u00edficas como BluetoothSerial y la importancia de configurar correctamente la velocidad de transmisi\u00f3n. Fue \u00fatil para visualizar c\u00f3mo los datos enviados desde una app pueden ser procesados en tiempo real por el ESP32 y mostrados en la computadora.</p>"},{"location":"Trabajo2/#codigo","title":"Codigo","text":"<pre><code>#include \"BluetoothSerial.h\"   \n\nBluetoothSerial SerialBT;      \nvoid setup() {\n  Serial.begin(115200);       \n  SerialBT.begin(\"ESP32A\u00d1\");   \n  Serial.println(\"Bluetooth listo. Esperando conexi\u00f3n...\");\n}\n\nvoid loop() {\n  if (SerialBT.available()) {                \n    String mensaje = SerialBT.readString();  \n    Serial.println(\"Recibido: \" + mensaje);  \n  delay(1000);  \n}\n</code></pre>"},{"location":"aa/","title":"Encendido de LED con Pulsador usando Arduino","text":""},{"location":"aa/#proposito","title":"Proposito","text":"<p>El objetivo principal de esta pr\u00e1ctica fue comprender el funcionamiento b\u00e1sico de entradas y salidas digitales en Arduino. Se busc\u00f3 controlar el encendido de un LED utilizando un bot\u00f3n f\u00edsico conectado a una protoboard, aplicando conceptos fundamentales de electr\u00f3nica como resistencias pull-down y l\u00f3gica de control.</p>"},{"location":"aa/#meta-de-la-practica","title":"Meta de la practica","text":"<p>Comprender el funcionamiento de entradas digitales en Arduino y aplicar este conocimiento para controlar un LED mediante un pulsador f\u00edsico.</p>"},{"location":"aa/#organizacion-del-equipo","title":"Organizaci\u00f3n del Equipo","text":"<p>El equipo se dividi\u00f3 en dos \u00e1reas principales: desarrollo del codigo de programacion y desarrollo electr\u00f3nico.</p>"},{"location":"aa/#materiales-utilizados","title":"Materiales Utilizados","text":"<ul> <li>Arduino UNO</li> <li>Protoboard </li> <li>LED rojo </li> <li>Resistencia de 220\u03a9 (limitadora para el LED)  </li> <li>Resistencia de 10k\u03a9 (pull-down para el bot\u00f3n)  </li> <li>Pulsador (bot\u00f3n) </li> <li>Cables de conexi\u00f3n (jumpers) </li> <li>Cable USB para cargar el programa</li> </ul>"},{"location":"aa/#tecnologias-utilizadas","title":"Tecnolog\u00edas Utilizadas","text":"<ul> <li>Lenguajes: <code>Python</code></li> <li>Hardware: <code>ESP32</code>, <code>Arduino</code></li> <li>Software: <code>ARDUINO IDE</code> </li> </ul>"},{"location":"aa/#sistema-electronico","title":"Sistema Electr\u00f3nico","text":"<p>El circuito se arm\u00f3 sobre una protoboard. El LED se conect\u00f3 al pin digital 13 del Arduino, con una resistencia de 220\u03a9 en serie para evitar sobrecorriente. El bot\u00f3n se conect\u00f3 al pin digital 2, acompa\u00f1ado de una resistencia de 10k\u03a9 como pull-down para asegurar que el estado del pin sea bajo cuando el bot\u00f3n no est\u00e1 presionado. La l\u00f3gica del circuito es simple: al presionar el bot\u00f3n, el pin digital lee un estado alto (HIGH) y enciende el LED; al soltarlo, el estado vuelve a bajo (LOW) y el LED se apaga.</p>"},{"location":"aa/#programacion","title":"Programaci\u00f3n","text":"<p>El c\u00f3digo fue escrito en Arduino IDE y se basa en la lectura del estado del bot\u00f3n para controlar el LED, el codigo se desarrollo en base y apoyo del codigo proporcionado por Oliver.</p>"},{"location":"aa/#resultados-y-observaciones","title":"Resultados y Observaciones","text":"<p>El circuito respondi\u00f3 correctamente al presionar el bot\u00f3n, encendiendo el LED de forma inmediata. Se comprob\u00f3 que la resistencia pull-down evit\u00f3 lecturas err\u00e1ticas cuando el bot\u00f3n no estaba presionado. La pr\u00e1ctica permiti\u00f3 verificar el funcionamiento b\u00e1sico de entradas y salidas digitales en Arduino, y se logr\u00f3 una interacci\u00f3n estable entre hardware y software</p>"},{"location":"aa/#evidencias","title":"Evidencias","text":"<p>Ver en YouTube</p>"},{"location":"aa/#reflexiones-finales","title":"Reflexiones Finales","text":"<p>Esta pr\u00e1ctica fue una excelente introducci\u00f3n al uso de microcontroladores. Se logr\u00f3 entender c\u00f3mo interact\u00faan los componentes electr\u00f3nicos b\u00e1sicos con el Arduino y c\u00f3mo la programaci\u00f3n puede controlar el comportamiento f\u00edsico de un sistema. Se aprendi\u00f3 la importancia de las resistencias pull-down para evitar lecturas err\u00e1ticas, y se reforz\u00f3 el concepto de entradas y salidas digitales. Adem\u00e1s, se comprob\u00f3 que incluso con un circuito sencillo se pueden lograr interacciones \u00fatiles entre hardware y software.</p>"},{"location":"aa/#codigo","title":"Codigo","text":"<pre><code>const int led=27;\nconst int button=32;\n\nvoid setup() {\n  Serial.begin(115200); //INICIO LA COMUNICACION EN 115200 char por segundo\n  pinMode(led,OUTPUT);\n  pinMode(button,INPUT);\n}\n\nvoid loop() {\n  int estado = digitalRead(button);\n  if(estado == 1){\n    digitalWrite(led,1);\n  }\n  else{\n    digitalWrite(led,0);\n\u00a0\u00a0}\n}\n</code></pre>"},{"location":"about/","title":"\u00bfQuien soy?","text":"<p>Mi nombre es Erik y actualmente estoy estudiando Ingenieria Mecatronica en la Ibero Puebla.</p> <p>En esta pagina resumire todos los proyectos que realice, con el fin de compartir mis conocimientos y aportes a la Mecatronica.</p>"},{"location":"about/#intereses-y-areas-de-enfoque","title":"Intereses y Areas de enfoque:","text":"<ul> <li>Me gusta aprender mucho todo lo que tiene que ver con informatica, tecnologia, innovacion y todo ello.</li> <li>Me gusta la intregacion de objetos que usamos en la vida cotidiana a la tecnologia.</li> <li>Me enfoco en los programas de modelado de piezas 3D</li> </ul>"},{"location":"about/#mis-aptitudes-son","title":"Mis aptitudes son:","text":"<ul> <li>Trabajo eficiente </li> <li>Resolucion de problemas </li> <li>Trabajo en equipo </li> <li>Facilidad de aprendizaje</li> </ul>"},{"location":"about/#de-que-me-siento-orgulloso","title":"\u00bfDe que me siento orgulloso?","text":"<p>En mi trayectoria por la preparatoria estuve involucrado en todo tipo de proyectos, buscando que estos me ense\u00f1aran algo y que me divirtiesen. Me siento realmente orgulloso de haber sido parte de todo lo que fue eventos escolares fuertes, participe como produccion ejecutiva en la obra escolar que es una obra de primer nivel, presidente de logistica en la Sociedad de Alumnos de mi preparatoria, rol importante en el equipo representativo de Basquetbol siendo seleccionado para las competencias estatales entre colegios jesuitas en 2024 y 2025.</p> <p>Erik Andr\u00e9 Zepeda Tapia | contacto: 204440@iberopuebla.mx </p> <p></p>"},{"location":"proyectobie/","title":"Proyecto Balsa Stewart","text":""},{"location":"proyectobie/#resumen","title":"Resumen","text":"<ul> <li>Nombre del proyecto: Plataforma niveladora con servomotores </li> <li>Equipo / Autor(es): Carlos Alberto Vasquez Perasa, Luis Hernesto Tamez Velazquez, Erik Andre Zepeda Tapia, Sebastian Gomez Rodrigues, Juan Manuel Gaona Serrano </li> <li>Curso / Asignatura: Introducci\u00f3n a la mecatronica </li> <li>Fecha: 05/11/2025 </li> <li>Descripci\u00f3n breve: Este proyecto consiste en el desarrollo e implementaci\u00f3n de una plataforma de autonivelaci\u00f3n basada en la Plataforma Stewart. Este tipo de plataforma se utiliza en diversas industrias, como en simuladores de vuelo y posicionamiento de precisi\u00f3n.</li> </ul>"},{"location":"proyectobie/#objetivo-principal","title":"Objetivo Principal","text":"<p>El objetivo principal es mantener un objeto, espec\u00edficamente una pelota, en una posici\u00f3n fija sobre la superficie de la plataforma, evitando su ca\u00edda.</p>"},{"location":"proyectobie/#objetivos-especificos","title":"Objetivos Espec\u00edficos:","text":"<p>Visi\u00f3n por Computadora: Una c\u00e1mara captura la posici\u00f3n y el color (rojo) de la pelota en tiempo real. Control: La informaci\u00f3n de la c\u00e1mara es procesada por un programa en phyton que manda informaci\u00f3n a un programa c++ que se encarga del control de un SP32, que a su ves controla los servomotores. Actuaci\u00f3n: La nivelaci\u00f3n se ejecuta mediante el control preciso de tres servomotores ubicados con una separaci\u00f3n de un angulo de 120\u00b0, los cuales ajustan los actuadores de la plataforma para inclinar y desplazar el plano y as\u00ed mantener la pelota en el centro.</p> <p>Incluye: Piezas de solidWorks y en .STL, planos para corte laser en .DXF, Codigo de la camara en phyton, codigo para SP32 en c++ - No incluye: La conexi\u00f3n de la parte mecanica, ni las medidad de los tornillos utilizados</p>"},{"location":"proyectobie/#meta-de-la-practica","title":"Meta de la practica","text":"<p>Establecer una comunicaci\u00f3n inal\u00e1mbrica entre el ESP32 y un celular mediante Bluetooth, para recibir mensajes escritos desde una app m\u00f3vil y mostrarlos en el monitor serial de la computadora.</p>"},{"location":"proyectobie/#organizacion-del-equipo","title":"Organizaci\u00f3n del Equipo","text":"<p>El equipo se dividi\u00f3 en dos \u00e1reas principales: desarrollo del codigo de programacion y desarrollo electr\u00f3nico.</p>"},{"location":"proyectobie/#materiales-utilizados","title":"Materiales Utilizados","text":"Nombre de la Pieza Cantidad Tornillo de cabeza de casquillo M2 x 8 6 Tornillo de cabeza de casquillo M2.5 x 10 4 Tornillo de cabeza de casquillo M3 x 5 18 Tornillo de cabeza de casquillo M3 x 10 3 Tornillo de cabeza de casquillo M3 x 15 1 Tornillo de cabeza de casquillo M3 x 20 3 Tornillo de cabeza de casquillo M4 x 20 6 Tornillo de cabeza de casquillo M4 x 30 6 Tornillo de cabeza de casquillo M5 x 30 3 BASE 3D 1 SEGUNDA BASE 3D 1 BRAZOS PRINCIPALES 3 BRAZOS SECUNDARIOS 3 Motores DC 15kg 180 grados 3 Balsa 1 Camara Webcam 1 Esp32 1 Protoboard 1 Jumpers +10 Cable usb A 1 ---"},{"location":"proyectobie/#tecnologias-utilizadas","title":"Tecnolog\u00edas Utilizadas","text":"<ul> <li>Lenguajes: <code>Python</code>, <code>C++</code>, <code>Visual Studio Code</code></li> <li>Hardware: <code>ESP32</code>, <code>Arduino</code></li> <li>Software: <code>ARDUINO IDE</code> </li> </ul>"},{"location":"proyectobie/#sistema-electronico","title":"Sistema Electr\u00f3nico","text":"<p>Componentes principales -Controlador: ESP32 (Wi-Fi/Bluetooth integrado). -Actuadores: 3 servos de alto torque (15\u202fkg\u00b7cm, 180\u00b0). -Fuente: Adaptador 5\u202fV (corriente suficiente para 3 servos + ESP32). -Interconexi\u00f3n: Protoboard + jumpers. -Extras: Webcam Logitech (alimentaci\u00f3n USB), volante Logitech G29 (alimentaci\u00f3n propia), torniller\u00eda para montaje.</p>"},{"location":"proyectobie/#diseno-electrico-y-consideraciones","title":"Dise\u00f1o el\u00e9ctrico y consideraciones","text":"<ol> <li>Alimentaci\u00f3n</li> </ol>"},{"location":"proyectobie/#ingenieria-de-la-carcasa","title":"Ingenier\u00eda de la carcasa","text":"<p>Se eligi\u00f3 PLA (impresi\u00f3n FDM) por su facilidad de fabricaci\u00f3n y rigidez adecuada para temperaturas hasta ~55\u201360\u202f\u00b0C. Las paredes principales son de 2.4\u202fmm (tres per\u00edmetros de 0.8\u202fmm), con nervaduras internas de 3\u202fmm para reducir flexi\u00f3n en la tapa superior. Se a\u00f1adieron insertos roscados M3 por calor en cuatro pilares, mejorando el ciclo de mantenimiento sin degradar el material. La ventilaci\u00f3n se resolvi\u00f3 con ranuras de 6\u00d71\u202fmm alineadas sobre el regulador DC-DC y el driver del motor; la orientaci\u00f3n de capa minimiza concentraciones de tensi\u00f3n en las esquinas (chaflanes de 1.5\u202fmm). Se verific\u00f3 holgura de 0.3\u202fmm para acoplar el sensor N y evitar interferencias con el mazo de cables.</p>"},{"location":"proyectobie/#programacion","title":"Programaci\u00f3n","text":"<p>Todos los codigos desarrollados por el equipo se encuentran al final del reporte :)</p> <p> </p>"},{"location":"proyectobie/#resultados-y-observaciones","title":"Resultados y Observaciones","text":"<p>La conexi\u00f3n Bluetooth fue exitosa y estable. Los mensajes escritos desde el celular se reflejaban correctamente en el monitor serial. El ESP32 respondi\u00f3 de forma inmediata a los datos recibidos. No se presentaron errores de transmisi\u00f3n ni desconexiones durante la prueba.</p>"},{"location":"proyectobie/#evidencias","title":"Evidencias","text":"<p>Ver en YouTube Ver en YouTube</p>"},{"location":"proyectobie/#piezas-disenadas-en-stl","title":"Piezas Dise\u00f1adas en STL","text":"<p>Dise\u00f1o de piezas en STL Las piezas del proyecto fueron modeladas en software CAD y exportadas en formato STL para su fabricaci\u00f3n mediante impresi\u00f3n 3D. En las siguientes im\u00e1genes, tomadas desde PrusaSlicer, se aprecia la disposici\u00f3n y orientaci\u00f3n de las piezas sobre la cama de impresi\u00f3n, as\u00ed como los par\u00e1metros de configuraci\u00f3n utilizados para optimizar la calidad y resistencia:</p> <p>Estas configuraciones garantizan una fabricaci\u00f3n precisa, reduciendo desperdicio de material y asegurando la funcionalidad mec\u00e1nica del conjunto.</p> <p> </p>"},{"location":"proyectobie/#reflexiones-finales","title":"Reflexiones Finales","text":"<p>Al comenzar este proyecto, enfrentamos un gran desaf\u00edo tanto en la parte mec\u00e1nica como en la l\u00f3gica de programaci\u00f3n, ya que era un territorio nuevo dentro de nuestros conocimientos. Puedo decir que la visi\u00f3n artificial result\u00f3 ser una herramienta muy pr\u00e1ctica y \u00fatil en nuestra vida diaria; nunca imagin\u00e1bamos todo lo que podr\u00edamos lograr aplic\u00e1ndola.</p> <p>Durante el desarrollo aprendimos a gestionar mejor nuestro tiempo, a ver m\u00e1s all\u00e1 de la electr\u00f3nica e incorporar tambi\u00e9n los aspectos mec\u00e1nicos, f\u00edsicos y cinem\u00e1ticos del sistema. Esto nos permiti\u00f3 comprender mejor el comportamiento del conjunto y detectar fallas con mayor precisi\u00f3n, como la inclinaci\u00f3n de los servomotores, las librer\u00edas utilizadas, los m\u00e9todos de detecci\u00f3n y los materiales empleados.</p> <p>A pesar de ser un proceso exigente y lleno de retos, tambi\u00e9n fue una experiencia divertida y emocionante. Sin duda, esperamos realizar m\u00e1s proyectos de este tipo en el futuro para seguir aprendiendo y mejorando nuestras habilidades en ingenier\u00eda\u00a0mecatr\u00f3nica.sino que tambi\u00e9n abri\u00f3 oportunidades para futuras mejoras, como la optimizaci\u00f3n del consumo energ\u00e9tico y la incorporaci\u00f3n de sistemas m\u00e1s avanzados de control y sensorizaci\u00f3n.</p>"},{"location":"proyectobie/#codigo-principal","title":"Codigo Principal","text":"<pre><code>import cv2\nimport numpy as np\nimport math\nimport serial\nimport time\n\n\n# ===================== CONFIGURACION SERIAL =====================\nPUERTO_SERIAL = 'COM11' # &lt;-- AJUSTA ESTO AL PUERTO DE TU ESP32\nBAUDRATE = 115200\nTIMEOUT = 0.01\n\n\ntry:\n    arduino = serial.Serial(PUERTO_SERIAL, BAUDRATE, timeout=TIMEOUT)\n    time.sleep(2)\n    print(\"\u2713 Serial conectado en\", PUERTO_SERIAL)\nexcept Exception as e:\n    print(f\"\u2717 ERROR: No se pudo conectar en {PUERTO_SERIAL}. {e}\")\n    arduino = None\n\n# ===================== PARAMETROS HOUGH (PLATO) =====================\ndp       = 0.8\nminDist  = 280\nparam1   = 165\nparam2   = 15\nminRadius = 130\nmaxRadius = 211\n\n\n# ===================== FILTRO EXPONENCIAL DEL PLATO =====================\nalpha_plato = 0.9 \nplato_cx_f = plato_cy_f = plato_r_f = None \n\n\n# ===================== COEFICIENTES DE SUAVIZADO DE ERROR =====================\nalpha_err = 0.6\nerrX_f = errY_f = 0.0 \n\n\n# ===================== VIDEO =====================\ncap = cv2.VideoCapture(0)\ncap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)\ncap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)\n\n\n# ===================== ANGULOS DE SERVO (INICIALES) =====================\nBASE_ANGLE = 50.0 \nMIN_ANGLE = 30.0  \nMAX_ANGLE = 70.0   \n\n\nCOS_30 = math.cos(math.radians(30)) \nSIN_30 = math.sin(math.radians(30)) \n\n\n# ===================== PID BASICO =====================\nclass PID:\n    def __init__(self, Kp, Ki, Kd, setpoint=0, dt=0.03):\n        self.Kp = Kp\n        self.Ki = Ki\n        self.Kd = Kd\n        self.setpoint = setpoint\n        self.dt = dt\n        self.prev_error = 0\n        self.integral = 0\n\n\n    def update(self, measurement):\n        error = self.setpoint - measurement\n        self.integral += error * self.dt\n        self.integral = np.clip(self.integral, -50, 50) \n        derivative = (error - self.prev_error) / self.dt\n\n        output = self.Kp * error + self.Ki * self.integral + self.Kd * derivative\n\n        output = np.clip(output, -20, 20)\n        self.prev_error = error\n        return output\n\n\n# Inicializar PIDs de inclinaci\u00f3n\npid_dt = 0.03 \npid_x = PID(Kp=10.0, Ki=0.2, Kd=1.0, dt=pid_dt) \npid_y = PID(Kp=10.0, Ki=0.2, Kd=1.0, dt=pid_dt)\n\n\n# ===================== CINEM\u00c1TICA DE 3 SERVOS =====================\ndef calcular_angulos_servos(theta_x, theta_y, base_angle, min_angle, max_angle):\n    angle_1 = base_angle + theta_y \n    angle_2 = base_angle + (theta_x * COS_30) - (theta_y * SIN_30)\n    angle_3 = base_angle - (theta_x * COS_30) - (theta_y * SIN_30)\n\n    angle_1 = np.clip(angle_1, min_angle, max_angle)\n    angle_2 = np.clip(angle_2, min_angle, max_angle)\n    angle_3 = np.clip(angle_3, min_angle, max_angle)\n\n    return int(angle_1), int(angle_2), int(angle_3)\n\n\n# ===================== ENVIO DE CONFIGURACION AL ESP32 =====================\ndef enviar_config_angulos(base, min_ang, max_ang):\n    \"\"\"Env\u00eda la configuraci\u00f3n de \u00e1ngulos al ESP32\"\"\"\n    if arduino is not None:\n        try:\n            comando_config = f\"CFG:BASE:{base},MIN:{min_ang},MAX:{max_ang}\\n\"\n            arduino.write(comando_config.encode('ascii'))\n            print(f\"\u2713 Config enviada: BASE={base}\u00b0, MIN={min_ang}\u00b0, MAX={max_ang}\u00b0\")\n        except Exception as e:\n            print(f\"Error al enviar config: {e}\")\n\n\n# ===================== CONFIGURACI\u00d3N DE TRACKBARS =====================\ndef on_trackbar(val):\n    pass\n\n\n# Funci\u00f3n para crear imagen de informaci\u00f3n con valores reales\ndef crear_imagen_info_pid(kp, ki, kd):\n    img = np.zeros((150, 400, 3), dtype=np.uint8)\n    img[:] = (40, 40, 40)  # Fondo gris oscuro\n\n    font = cv2.FONT_HERSHEY_SIMPLEX\n    cv2.putText(img, \"VALORES PID ACTUALES\", (70, 30), font, 0.7, (255, 255, 255), 2)\n    cv2.line(img, (20, 40), (380, 40), (100, 100, 100), 1)\n\n    cv2.putText(img, f\"Kp = {kp:.2f}\", (50, 75), font, 0.8, (0, 255, 255), 2)\n    cv2.putText(img, f\"Ki = {ki:.3f}\", (50, 105), font, 0.8, (0, 255, 255), 2)\n    cv2.putText(img, f\"Kd = {kd:.2f}\", (50, 135), font, 0.8, (0, 255, 255), 2)\n\n    return img\n\n\ndef crear_imagen_info_angulos(base, min_ang, max_ang):\n    img = np.zeros((150, 400, 3), dtype=np.uint8)\n    img[:] = (40, 40, 40)  # Fondo gris oscuro\n\n    font = cv2.FONT_HERSHEY_SIMPLEX\n    cv2.putText(img, \"ANGULOS DE SERVOS\", (85, 30), font, 0.7, (255, 255, 255), 2)\n    cv2.line(img, (20, 40), (380, 40), (100, 100, 100), 1)\n\n    cv2.putText(img, f\"Base = {base}.0 grados\", (50, 75), font, 0.7, (255, 165, 0), 2)\n    cv2.putText(img, f\"Min  = {min_ang}.0 grados\", (50, 105), font, 0.7, (255, 165, 0), 2)\n    cv2.putText(img, f\"Max  = {max_ang}.0 grados\", (50, 135), font, 0.7, (255, 165, 0), 2)\n\n    return img\n\n\n# Crear ventana de control PID\ncv2.namedWindow(\"PID Tuner\")\ncv2.resizeWindow(\"PID Tuner\", 400, 150)\n\n# Trackbars PID (sin texto de unidades, se muestra en la imagen)\ncv2.createTrackbar(\"Kp x10\", \"PID Tuner\", int(pid_x.Kp * 10), 500, on_trackbar)\ncv2.createTrackbar(\"Ki x100\", \"PID Tuner\", int(pid_x.Ki * 100), 100, on_trackbar)\ncv2.createTrackbar(\"Kd x10\", \"PID Tuner\", int(pid_x.Kd * 10), 50, on_trackbar)\n\n# Crear ventana de control de \u00c1ngulos\ncv2.namedWindow(\"Servo Angles\")\ncv2.resizeWindow(\"Servo Angles\", 400, 150)\n\n# Trackbars de \u00e1ngulos (0-180 grados)\ncv2.createTrackbar(\"Base\", \"Servo Angles\", int(BASE_ANGLE), 180, on_trackbar)\ncv2.createTrackbar(\"Min\", \"Servo Angles\", int(MIN_ANGLE), 180, on_trackbar)\ncv2.createTrackbar(\"Max\", \"Servo Angles\", int(MAX_ANGLE), 180, on_trackbar)\n\n# Enviar configuraci\u00f3n inicial\nenviar_config_angulos(int(BASE_ANGLE), int(MIN_ANGLE), int(MAX_ANGLE))\n\nprint(\"\ud83c\udfaf Detecci\u00f3n de Plato y Errores de Pelota (Fondo Negro)\")\nprint(\"\ud83d\udcd0 Ajusta los \u00e1ngulos en tiempo real con los sliders\")\nprint(\"Presiona 'q' para salir\")\n\n# Variables para detectar cambios en \u00e1ngulos\nprev_base = int(BASE_ANGLE)\nprev_min = int(MIN_ANGLE)\nprev_max = int(MAX_ANGLE)\n\n# Bucle principal de control\nwhile True:\n    # --- LECTURA Y ACTUALIZACI\u00d3N DEL PID ---\n    kp_val = cv2.getTrackbarPos(\"Kp x10\", \"PID Tuner\") / 10.0\n    ki_val = cv2.getTrackbarPos(\"Ki x100\", \"PID Tuner\") / 100.0\n    kd_val = cv2.getTrackbarPos(\"Kd x10\", \"PID Tuner\") / 10.0\n\n    pid_x.Kp, pid_x.Ki, pid_x.Kd = kp_val, ki_val, kd_val\n    pid_y.Kp, pid_y.Ki, pid_y.Kd = kp_val, ki_val, kd_val\n\n    # --- LECTURA DE \u00c1NGULOS DESDE TRACKBARS ---\n    current_base = cv2.getTrackbarPos(\"Base\", \"Servo Angles\")\n    current_min = cv2.getTrackbarPos(\"Min\", \"Servo Angles\")\n    current_max = cv2.getTrackbarPos(\"Max\", \"Servo Angles\")\n\n    # Mostrar valores reales en las ventanas de trackbars\n    img_pid_info = crear_imagen_info_pid(kp_val, ki_val, kd_val)\n    cv2.imshow(\"PID Tuner\", img_pid_info)\n\n    img_angle_info = crear_imagen_info_angulos(current_base, current_min, current_max)\n    cv2.imshow(\"Servo Angles\", img_angle_info)\n\n    # Validar que Min &lt; Base &lt; Max\n    if current_min &gt;= current_max:\n        current_max = current_min + 1\n        cv2.setTrackbarPos(\"Max\", \"Servo Angles\", current_max)\n\n    if current_base &lt; current_min:\n        current_base = current_min\n        cv2.setTrackbarPos(\"Base\", \"Servo Angles\", current_base)\n    elif current_base &gt; current_max:\n        current_base = current_max\n        cv2.setTrackbarPos(\"Base\", \"Servo Angles\", current_base)\n\n    # Detectar cambios y enviar nueva configuraci\u00f3n\n    if (current_base != prev_base or current_min != prev_min or current_max != prev_max):\n        enviar_config_angulos(current_base, current_min, current_max)\n        prev_base, prev_min, prev_max = current_base, current_min, current_max\n\n    # --- RESTO DE L\u00d3GICA DE VISI\u00d3N Y CONTROL ---\n    ret, frame = cap.read()\n    if not ret:\n        break\n\n    frame = cv2.flip(frame, 1)\n    frame_display = frame.copy() \n\n    # --- 1) DETECCION DEL PLATO (HOUGH) ---\n    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n    blurred = cv2.GaussianBlur(gray, (5,5), 0)\n    circles = cv2.HoughCircles(\n        blurred, cv2.HOUGH_GRADIENT,\n        dp=dp, minDist=minDist,\n        param1=param1, param2=param2,\n        minRadius=minRadius, maxRadius=maxRadius\n    )\n\n    plato_cx, plato_cy, plato_r = None, None, None\n\n    if circles is not None:\n        circles = np.round(circles[0, :]).astype(\"int\")\n        radios = [r for (_,_,r) in circles]\n        idx = np.argmax(radios)\n        plato_cx, plato_cy, plato_r = circles[idx]\n\n        if plato_cx_f is None:\n            plato_cx_f, plato_cy_f, plato_r_f = plato_cx, plato_cy, plato_r\n        else:\n            plato_cx_f = int(alpha_plato*plato_cx + (1-alpha_plato)*plato_cx_f)\n            plato_cy_f = int(alpha_plato*plato_cy + (1-alpha_plato)*plato_cy_f)\n            plato_r_f  = int(alpha_plato*plato_r + (1-alpha_plato)*plato_r_f)\n\n        cv2.circle(frame_display, (plato_cx_f, plato_cy_f), plato_r_f, (0,255,0), 3)\n        cv2.circle(frame_display, (plato_cx_f, plato_cy_f), 6, (0,255,0), -1) # Centro\n\n        # --- NUEVO C\u00cdRCULO: ZONA MUERTA ---\n        DEADZONE_RADIUS = 10 # Radio en p\u00edxeles para la zona muerta (ajusta si es necesario)\n        cv2.circle(frame_display, (plato_cx_f, plato_cy_f), DEADZONE_RADIUS, (0,165,255), 2)\n\n        cv2.putText(frame_display, f\"PLATO DETECTADO (r={plato_r_f})\", \n                             (plato_cx_f - 120, plato_cy_f - plato_r_f - 10), \n                             cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,255,0), 2)\n    else:\n        plato_cx_f = plato_cy_f = plato_r_f = None\n        cv2.putText(frame_display, \"PLATO NO DETECTADO\", (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,0,255), 2)\n\n    # --- A) ENMASCARAMIENTO CIRCULAR (FONDO NEGRO) ---\n    if plato_cx_f is not None:\n        mask_plato = np.zeros(frame.shape[:2], dtype=\"uint8\")\n        cv2.circle(mask_plato, (plato_cx_f, plato_cy_f), plato_r_f - 5, 255, -1) \n        frame_deteccion = cv2.bitwise_and(frame, frame, mask=mask_plato)\n    else:\n        frame_deteccion = frame\n\n    # --- 2) DETECCION PELOTA ROJA (COLOR / CENTROIDE) ---\n    red_low1  = np.array([0, 150, 50], np.uint8)\n    red_high1 = np.array([8, 255, 255], np.uint8)\n    red_low2  = np.array([170, 150, 50], np.uint8)\n    red_high2 = np.array([179, 255, 255], np.uint8)\n\n    hsv = cv2.cvtColor(frame_deteccion, cv2.COLOR_BGR2HSV)\n    mask1 = cv2.inRange(hsv, red_low1, red_high1)\n    mask2 = cv2.inRange(hsv, red_low2, red_high2)\n    mask = cv2.add(mask1, mask2)\n\n    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))\n    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)\n    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)\n\n    contornos, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n    mejor_c = None\n    mejor_cx = mejor_cy = 0\n    mejor_area = 0\n\n    for c in contornos:\n        area = cv2.contourArea(c)\n        if 100 &lt; area &lt; 5000:\n            M = cv2.moments(c)\n            if M[\"m00\"] != 0:\n                cx = int(M[\"m10\"]/M[\"m00\"])\n                cy = int(M[\"m01\"]/M[\"m00\"])\n\n                if mejor_c is None or area &gt; mejor_area:\n                    mejor_c, mejor_cx, mejor_cy, mejor_area = c, cx, cy, area\n\n    # --- 3) CALCULO Y SUAVIZADO DE ERROR ---\n    errX_raw = 0.0\n    errY_raw = 0.0\n    pelota_detectada = False\n\n    if mejor_c is not None and plato_cx_f is not None:\n        dist_al_centro = math.hypot(mejor_cx - plato_cx_f, mejor_cy - plato_cy_f)\n\n        if dist_al_centro &lt; plato_r_f:\n            pelota_detectada = True\n\n            errX_raw = mejor_cx - plato_cx_f \n            errY_raw = mejor_cy - plato_cy_f \n\n            if plato_r_f &gt; 0:\n                 errX_norm = errX_raw / plato_r_f\n                 errY_norm = errY_raw / plato_r_f\n            else:\n                 errX_norm, errY_norm = 0.0, 0.0\n\n            errX_f = alpha_err * errX_norm + (1-alpha_err) * errX_f\n            errY_f = alpha_err * errY_norm + (1-alpha_err) * errY_f\n\n            cv2.circle(frame_display, (mejor_cx, mejor_cy), 8, (0,0,255), -1)\n            cv2.line(frame_display, (mejor_cx, mejor_cy), (plato_cx_f, plato_cy_f), (255,0,0), 2)\n\n        else:\n            errX_f, errY_f = 0.0, 0.0\n            # RESETEAR PID cuando no hay pelota\n            pid_x.integral = 0.0\n            pid_y.integral = 0.0\n            pid_x.prev_error = 0.0\n            pid_y.prev_error = 0.0\n    else:\n        errX_f, errY_f = 0.0, 0.0\n        # RESETEAR PID cuando no hay pelota\n        pid_x.integral = 0.0\n        pid_y.integral = 0.0\n        pid_x.prev_error = 0.0\n        pid_y.prev_error = 0.0\n\n    # --- 4) CONTROL PID Y ENV\u00cdO SERIAL (\ud83c\udfaf L\u00d3GICA CORREGIDA) ---\n    errX_input = errX_f * 100\n    errY_input = errY_f * 100\n\n    # Zona muerta para estabilidad\n    DEADZONE_ERR_INPUT = 5.0\n    if abs(errX_input) &lt; DEADZONE_ERR_INPUT:\n        errX_input = 0.0\n    if abs(errY_input) &lt; DEADZONE_ERR_INPUT:\n        errY_input = 0.0\n\n    # \ud83c\udfaf CORRECCI\u00d3N CLAVE: INVERTIR SE\u00d1AL DE CONTROL\n    theta_X = -pid_x.update(errX_input)  # \u2190 NEGATIVO: COMPENSA el error\n    theta_Y = -pid_y.update(errY_input)  # \u2190 NEGATIVO: COMPENSA el error\n\n    # Limitar inclinaciones extremas\n    theta_X = np.clip(theta_X, -25, 25)\n    theta_Y = np.clip(theta_Y, -25, 25)\n\n    A1, A2, A3 = calcular_angulos_servos(theta_X, theta_Y, current_base, current_min, current_max)\n\n    comando = f\"A1:{A1},A2:{A2},A3:{A3}\\n\"\n\n    if arduino is not None:\n        try:\n            arduino.write(comando.encode('ascii'))\n        except Exception as e:\n            print(f\"Error al enviar datos: {e}\")\n\n    # --- 5) HUD FINAL ---\n    font = cv2.FONT_HERSHEY_SIMPLEX\n\n    cv2.putText(frame_display, f\"Kp:{kp_val:.1f} Ki:{ki_val:.2f} Kd:{kd_val:.1f}\", \n                (10, frame_display.shape[0]-120), font, 0.5, (255,255,0), 2)\n\n    cv2.putText(frame_display, f\"Base:{current_base} Min:{current_min} Max:{current_max}\", \n                (10, frame_display.shape[0]-95), font, 0.5, (255,165,0), 2)\n\n    cv2.putText(frame_display, f\"Angulos: A1:{A1} A2:{A2} A3:{A3}\", \n                (10, frame_display.shape[0]-70), font, 0.5, (255,255,0), 2)\n\n    if pelota_detectada:\n        cv2.putText(frame_display, \n                    f'Inclinacion X,Y: ({theta_X:+.1f} deg, {theta_Y:+.1f} deg)', \n                    (10, frame_display.shape[0]-45), font, 0.5, (0,255,0), 2)\n        cv2.putText(frame_display, \n                    f'Error Norm X,Y: ({errX_f:+.2f}, {errY_f:+.2f})', \n                    (10, frame_display.shape[0]-20), font, 0.5, (0,255,255), 2)\n    else:\n        cv2.putText(frame_display, \"PELOTA NO DETECTADA O FUERA DEL PLATO\", \n                    (10, frame_display.shape[0]-20), font, 0.5, (0,165,255), 2)\n\n    cv2.imshow('CONTROL DE BALANZA (PID ACTIVO)', frame_display)\n    cv2.imshow('Imagen de Deteccion (Solo Plato Visible)', frame_deteccion)\n\n    if cv2.waitKey(1) &amp; 0xFF == ord('q'):\n        break\n\n    time.sleep(pid_dt) \n\n# ===================== LIMPIEZA =====================\nprint(\"\\n\u2713 Sistema cerrado. Centrando Servos...\")\nif arduino is not None:\n    comando_cierre = f\"A1:{current_base},A2:{current_base},A3:{current_base}\\n\"\n    arduino.write(comando_cierre.encode('ascii'))\n    time.sleep(0.5)\n    arduino.close()\n\ncap.release()\ncv2.destroyAllWindows()\n</code></pre>"},{"location":"proyectobie/#codigo-test-de-cuadrantes","title":"Codigo Test de Cuadrantes","text":"<pre><code>import cv2\nimport numpy as np\nimport serial\nimport serial.tools.list_ports\nimport time\nimport math\n\n# Configuraci\u00f3n serial ARDUINO UNO\nPUERTO_SERIAL = 'COM11'\nBAUDRATE = 11520\nTIMEOUT = 0.01\n\n# Slicers interactivos para \u00e1rea\nmin_area = 100\nmax_area = 8000\nalto_slicer = 30\n\n# Variables globales para mouse\nmouse_x, mouse_y = 0, 0\n\n# Funci\u00f3n para encontrar puerto Arduino autom\u00e1ticamente\ndef encontrar_arduino():\n    puertos = serial.tools.list_ports.comports()\n    for puerto in puertos:\n        if 'Arduino' in puerto.description or 'CH340' in puerto.description or 'USB-SERIAL' in puerto.description:\n            return puerto.device\n    return None\n\n# Funci\u00f3n slicer interactivo\ndef dibujar_slicer(frame, y_pos, valor, label, min_val, max_val, color=(0,255,0)):\n    ancho = frame.shape[1] - 20\n    x_inicio = 10\n\n    cv2.rectangle(frame, (x_inicio, y_pos), (x_inicio + ancho, y_pos + alto_slicer), (50,50,50), -1)\n\n    proporcion = (valor - min_val) / (max_val - min_val)\n    ancho_activo = int(proporcion * ancho)\n    cv2.rectangle(frame, (x_inicio, y_pos), (x_inicio + ancho_activo, y_pos + alto_slicer), color, -1)\n\n    cv2.putText(frame, f'{label}: {int(valor)}', (x_inicio, y_pos-5), \n                cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255,255,255), 2)\n\n    cv2.putText(frame, f'[{min_val}-{max_val}]', (x_inicio + ancho + 10, y_pos + 22), \n                cv2.FONT_HERSHEY_SIMPLEX, 0.5, (150,150,150), 1)\n\n# \ud83d\udd25 FUNCI\u00d3N 6 CUADRANTES POLARES (60\u00b0 cada uno)\ndef obtener_cuadrante_6(cx, cy, centrox, centroy):\n    \"\"\"\n    Divide en 6 cuadrantes polares cada 60\u00b0 + CENTRO_SUP/INF\n    \u00c1ngulos: 0\u00b0(Der), 60\u00b0, 120\u00b0, 180\u00b0(Izq), 240\u00b0, 300\u00b0\n    \"\"\"\n    dx = cx - centrox\n    dy = cy - centroy\n\n    # Distancia desde centro (para detectar centro)\n    distancia = math.sqrt(dx**2 + dy**2)\n    radio_centro = 50  # P\u00edxeles para considerar \"centro\"\n\n    if distancia &lt; radio_centro:\n        if dy &lt; 0:  # CENTRO_SUPERIOR\n            return \"CENTRO_SUP\", 0.0, 0.0, (0, 255, 255)\n        else:       # CENTRO_INFERIOR\n            return \"CENTRO_INF\", 0.0, 0.0, (255, 255, 0)\n\n    # \u00c1ngulo polar (0\u00b0=derecha, sentido antihorario)\n    angulo = math.atan2(dy, dx) * 180 / math.pi\n    if angulo &lt; 0:\n        angulo += 360\n\n    # Dividir en 6 sectores de 60\u00b0\n    sector = int(angulo // 60)\n\n    if sector == 0:\n        cuadrante = \"Cuadrante 6\"\n        color_cuad = (0, 0, 255)  # Rojo\n    elif sector == 1:\n        cuadrante = \"Cuadrante 5\"\n        color_cuad = (0, 165, 255)  # Naranja\n    elif sector == 2:\n        cuadrante = \"Cuadrante 4\"\n        color_cuad = (255, 0, 255)  # Magenta\n    elif sector == 3:\n        cuadrante = \"Cuadrante 3\"\n        color_cuad = (255, 255, 0)  # Cian\n    elif sector == 4:\n        cuadrante = \"Cuadrante 2\"\n        color_cuad = (255, 0, 0)  # Rosa\n    else:  # sector == 5\n        cuadrante = \"Cuadrante 1\"\n        color_cuad = (0, 255, 0)  # Verde\n\n    # Errores normalizados por distancia m\u00e1xima\n    dist_max = 250  # Radio m\u00e1ximo para normalizaci\u00f3n\n    error_magnitud = np.clip(distancia / dist_max, 0, 1.0)\n\n    # Direcci\u00f3n del error (vector unitario)\n    errorX_norm = (dx / distancia) * error_magnitud if distancia &gt; 0 else 0\n    errorY_norm = (dy / distancia) * error_magnitud if distancia &gt; 0 else 0\n\n    return cuadrante, errorX_norm, errorY_norm, color_cuad\n\n# Mouse callback para ventana SLICER\ndef mouse_callback_slicer(event, x, y, flags, param):\n    global min_area, max_area, mouse_x, mouse_y\n    mouse_x, mouse_y = x, y\n\n    if event == cv2.EVENT_MOUSEWHEEL:\n        if 100 &lt;= y &lt;= 160:\n            delta = 50 if event &gt; 0 else -50\n            if 100 &lt;= y &lt;= 130:\n                min_area = np.clip(min_area + delta, 50, 5000)\n            else:\n                max_area = np.clip(max_area + delta * 2, 500, 15000)\n\n# Inicializar comunicaci\u00f3n serial\nprint(\"\ud83d\udd0d Buscando Arduino en COM11...\")\ntry:\n    arduino = serial.Serial(PUERTO_SERIAL, BAUDRATE, timeout=TIMEOUT)\n    time.sleep(2)\n    print(\"\u2713 Serial conectado en COM11\")\nexcept:\n    print(\"\u2717 ERROR: No se pudo conectar en COM11\")\n    exit()\n\n# Clase PID\nclass PID:\n    def __init__(self, Kp, Ki, Kd, setpoint=0, dt=0.03):\n        self.Kp = Kp\n        self.Ki = Ki\n        self.Kd = Kd\n        self.setpoint = setpoint\n        self.dt = dt\n        self.prev_error = 0\n        self.integral = 0\n        self.output = 0\n\n    def update(self, measurement):\n        error = self.setpoint - measurement\n        self.integral += error * self.dt\n        self.integral = np.clip(self.integral, -50, 50)\n        derivative = (error - self.prev_error) / self.dt\n        self.output = self.Kp * error + self.Ki * self.integral + self.Kd * derivative\n        self.output = np.clip(self.output, -90, 90)\n        self.prev_error = error\n        return self.output\n\n# Inicializar PIDs\npid_x = PID(Kp=0.8, Ki=0.05, Kd=0.15)\npid_y = PID(Kp=0.8, Ki=0.05, Kd=0.15)\npid_area = PID(Kp=0.3, Ki=0.02, Kd=0.08, setpoint=2000)\n\ncap = cv2.VideoCapture(0)\ncap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)\ncap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)\nalpha = 0.6\nprev_errorX, prev_errorY = 0, 0\n\nprint(\"\\n\ud83c\udfaf BALANZA PID 3D - 6 CUADRANTES POLARES\")\nprint(\"VENTANA 1: 'Camera' \u2192 6 sectores 60\u00b0 + CENTRO_SUP/INF\")\nprint(\"VENTANA 2: 'SLICER' \u2192 \u2191\u2193Rueda | A/Z:Min | S/X:Max\")\n\n# 2 VENTANAS\nventana_camera = 'Camera - 6 CUADRANTES POLARES'\nventana_slicer = 'SLICER CONTROL'\n\ncv2.namedWindow(ventana_camera)\ncv2.namedWindow(ventana_slicer)\ncv2.setMouseCallback(ventana_slicer, mouse_callback_slicer)\n\nframe_slicer = np.zeros((200, 320, 3), dtype=np.uint8)\nframe_slicer.fill(20)\n\nwhile True:\n    ret, frame = cap.read()\n    if not ret:\n        break\n\n    frame = cv2.flip(frame, 1)\n    centrox = frame.shape[1] // 2\n    centroy = frame.shape[0] // 2\n\n    # Detecci\u00f3n roja\n    redbajo1 = np.array([0, 150, 50], np.uint8)\n    redalto1 = np.array([8, 255, 255], np.uint8)\n    redbajo2 = np.array([170, 150, 50], np.uint8)\n    redalto2 = np.array([179, 255, 255], np.uint8)\n\n    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)\n    mask1 = cv2.inRange(hsv, redbajo1, redalto1)\n    mask2 = cv2.inRange(hsv, redbajo2, redalto2)\n    mask = cv2.add(mask1, mask2)\n\n    kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5,5))\n    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)\n    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)\n\n    contornos, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n\n    mejor_contorno = None\n    mejor_cx, mejor_cy, mejor_area = None, None, 0\n    cuadrante_actual = \"CENTRO\"\n    errorX_norm, errorY_norm = 0, 0\n\n    for c in contornos:\n        area = cv2.contourArea(c)\n        if min_area &lt; area &lt; max_area:\n            M = cv2.moments(c)\n            if M[\"m00\"] != 0:\n                cx = int(M[\"m10\"] / M[\"m00\"])\n                cy = int(M[\"m01\"] / M[\"m00\"])\n                if mejor_contorno is None or area &gt; mejor_area:\n                    mejor_contorno = c\n                    mejor_cx, mejor_cy = cx, cy\n                    mejor_area = area\n\n    if mejor_contorno is not None:\n        cuadrante_actual, errorX_norm, errorY_norm, color_cuad = obtener_cuadrante_6(\n            mejor_cx, mejor_cy, centrox, centroy\n        )\n\n        errorX = alpha * errorX_norm + (1-alpha) * prev_errorX\n        errorY = alpha * errorY_norm + (1-alpha) * prev_errorY\n        prev_errorX, prev_errorY = errorX, errorY\n    else:\n        errorX, errorY = 0, 0\n        arduino.write(b\"X:0,Y:0,Z:0\\n\")\n\n    outputX = pid_x.update(errorX * 100)\n    outputY = pid_y.update(errorY * 100)\n    outputArea = pid_area.update(mejor_area)\n\n    comando = f\"X:{int(outputX)},Y:{int(outputY)},Z:{int(outputArea)}\\n\"\n    arduino.write(comando.encode())\n\n    # \ud83d\udd25 VENTANA 1: C\u00c1MARA + 6 L\u00cdNEAS POLARES\n    font = cv2.FONT_HERSHEY_SIMPLEX\n\n    # C\u00edrculo centro + \u00e1rea sensible\n    cv2.circle(frame, (centrox, centroy), 10, (0, 255, 0), -1)\n    cv2.circle(frame, (centrox, centroy), 50, (0, 255, 0), 1)  # Radio CENTRO\n\n    # \ud83d\udd25 6 L\u00cdNEAS RADIALES CADA 60\u00b0 (150px largo)\n    radio_lineas = 150\n    for angulo in range(0, 360, 60):\n        rad = math.radians(angulo)\n        x_fin = int(centrox + radio_lineas * math.cos(rad))\n        y_fin = int(centroy + radio_lineas * math.sin(rad))\n        cv2.line(frame, (centrox, centroy), (x_fin, y_fin), (0, 255, 0), 2)\n\n    if mejor_contorno is not None:\n        cv2.circle(frame, (int(mejor_cx), int(mejor_cy)), 8, color_cuad, -1)\n        hull = cv2.convexHull(mejor_contorno)\n        cv2.drawContours(frame, [hull], 0, color_cuad, 3)\n\n        cv2.putText(frame, f'{cuadrante_actual}', (10, 30), font, 0.7, color_cuad, 2)\n        cv2.putText(frame, f'X:{errorX_norm:+.2f}', (10, 55), font, 0.6, (0,255,0), 2)\n        cv2.putText(frame, f'Y:{errorY_norm:+.2f}', (10, 80), font, 0.6, (0,255,0), 2)\n        cv2.putText(frame, f'A:{int(mejor_area)}', (10, 105), font, 0.6, (255,255,0), 2)\n        cv2.putText(frame, f'PID: X{int(outputX)} Y{int(outputY)} Z{int(outputArea)}', \n                   (10, frame.shape[0]-30), font, 0.5, (0,255,0), 2)\n    else:\n        cv2.putText(frame, 'NO BALL', (10, 105), font, 0.6, (0,0,255), 2)\n\n    # \ud83d\udd25 VENTANA 2: SLICERS\n    frame_slicer.fill(20)\n    dibujar_slicer(frame_slicer, 100, min_area, 'MIN_AREA', 50, 5000, (0,255,0))\n    dibujar_slicer(frame_slicer, 135, max_area, 'MAX_AREA', 500, 15000, (0,150,255))\n\n    cv2.circle(frame_slicer, (mouse_x, mouse_y), 5, (255,255,255), -1)\n\n    font_slicer = cv2.FONT_HERSHEY_SIMPLEX\n    cv2.putText(frame_slicer, f'\u2191\u2193Rueda sobre slicers', (10, 50), font_slicer, 0.4, (255,255,0), 1)\n    cv2.putText(frame_slicer, f'A/Z:Min\u00b1100 S/X:Max\u00b1200', (10, 75), font_slicer, 0.4, (255,255,0), 1)\n    cv2.putText(frame_slicer, f'Rango: {min_area}-{max_area}', (10, 180), font_slicer, 0.5, (0,255,255), 2)\n\n    cv2.imshow(ventana_camera, frame)\n    cv2.imshow(ventana_slicer, frame_slicer)\n\n    tecla = cv2.waitKey(1) &amp; 0xFF\n    if tecla == ord('a'): min_area = max(50, min_area - 100); print(f\"MIN_AREA: {min_area}\")\n    if tecla == ord('z'): min_area = min(5000, min_area + 100); print(f\"MIN_AREA: {min_area}\")\n    if tecla == ord('s'): max_area = max(500, max_area - 200); print(f\"MAX_AREA: {max_area}\")\n    if tecla == ord('x'): max_area = min(15000, max_area + 200); print(f\"MAX_AREA: {max_area}\")\n    if tecla == ord('q'):\n        break\n\n# Limpieza\narduino.write(b\"X:0,Y:0,Z:0\\n\")\ntime.sleep(0.5)\ncap.release()\narduino.close()\ncv2.destroyAllWindows()\nprint(\"\u2713 Sistema cerrado correctamente\")\n\n    Serial.println(\"Recibido: \" + mensaje);  \n  delay(1000);  \n}\n</code></pre>"}]}
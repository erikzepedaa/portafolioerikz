{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Veh\u00edculo Controlado por Bluetooth con Motores DC","text":""},{"location":"#proposito","title":"Proposito","text":"<p>Este proyecto consisti\u00f3 en el dise\u00f1o y construcci\u00f3n de un veh\u00edculo a control remoto, utilizando motores de corriente directa (DC), un puente H para el control de direcci\u00f3n, y un microcontrolador ESP32 para la comunicaci\u00f3n v\u00eda Bluetooth. El objetivo principal fue aplicar conocimientos b\u00e1sicos de electr\u00f3nica, mec\u00e1nica y programaci\u00f3n para competir en una din\u00e1mica de rob\u00f3tica.</p>"},{"location":"#metas-del-proyecto","title":"Metas del Proyecto","text":"<p>Meta General: Desarrollar un prototipo funcional de un coche a control remoto que pueda participar en una competencia de rob\u00f3tica, demostrando habilidades de dise\u00f1o, integraci\u00f3n de sistemas y trabajo en equipo. Metas Espec\u00edficas:</p> <p>Implementar un sistema de control que permita maniobrar el veh\u00edculo con precisi\u00f3n y velocidad. Dise\u00f1ar una pala frontal que facilite la interacci\u00f3n con objetos (como pelotas) durante la competencia. Optimizar el rendimiento del coche para lograr una ventaja competitiva en el juego.</p>"},{"location":"#alcance-del-proyecto","title":"Alcance del Proyecto","text":"<p>El proyecto abarc\u00f3 desde la conceptualizaci\u00f3n del dise\u00f1o hasta la implementaci\u00f3n completa del sistema electr\u00f3nico y mec\u00e1nico. Se trabaj\u00f3 con materiales accesibles y se estableci\u00f3 un l\u00edmite de dos semanas para su desarrollo. Incluye: - Dise\u00f1o estructural del veh\u00edculo - Integraci\u00f3n de componentes electr\u00f3nicos - Programaci\u00f3n del sistema de control - Pruebas funcionales previas a la competencia</p>"},{"location":"#proceso-de-trabajo","title":"Proceso de Trabajo","text":""},{"location":"#organizacion-del-equipo","title":"Organizaci\u00f3n del Equipo","text":"<p>El equipo se dividi\u00f3 en dos \u00e1reas principales: dise\u00f1o mec\u00e1nico y desarrollo electr\u00f3nico. Mientras algunos miembros se encargaron de la estructura del coche, otros se enfocaron en la programaci\u00f3n y conexiones.</p>"},{"location":"#materiales-utilizados","title":"Materiales Utilizados","text":"<ul> <li>2 motores DC</li> <li>Puente H</li> <li>ESP32</li> <li>Protoboard</li> <li>Jumpers</li> <li>LED</li> <li>Bater\u00eda de 9V</li> <li>MDF para la base</li> <li>PLA para impresi\u00f3n 3D de la pala frontal</li> </ul>"},{"location":"#tecnologias-utilizadas","title":"Tecnolog\u00edas Utilizadas","text":"<ul> <li>Lenguajes: <code>Python</code>, <code>C++</code></li> <li>Hardware: <code>ESP32</code>, <code>Arduino</code></li> <li>Software: <code>SolidWorks</code>, <code>PSeInt</code></li> <li>Otros: <code>CircuitVerse</code> </li> </ul>"},{"location":"#sistema-electronico","title":"Sistema Electr\u00f3nico","text":"<p>Se conectaron los motores al puente H, asegurando una correcta polaridad y conexi\u00f3n a tierra. Los pines IN1 a IN4 se configuraron para controlar la direcci\u00f3n de giro de los motores. La ESP32 se integr\u00f3 como unidad de control, con especial atenci\u00f3n a la asignaci\u00f3n de pines y la protecci\u00f3n contra cortocircuitos.</p>"},{"location":"#programacion","title":"Programaci\u00f3n","text":"<p>Se desarroll\u00f3 un programa en Arduino IDE que permite controlar el coche mediante una aplicaci\u00f3n Bluetooth. Las funciones principales incluyeron:</p> <ul> <li>Avanzar</li> <li>Retroceder</li> <li>Girar a la izquierda/derecha</li> <li>Detenerse</li> <li>Ajustar velocidad mediante PWM</li> </ul> <p>La l\u00f3gica de movimiento se bas\u00f3 en la manipulaci\u00f3n de los motores: por ejemplo, para girar, se detiene una rueda mientras la otra sigue girando. El codigo para controlar el coche se encuentr al final del articulo.</p>"},{"location":"#resultados-y-observaciones","title":"Resultados y Observaciones","text":"<p>Antes de la competencia, el coche mostr\u00f3 un buen desempe\u00f1o: respond\u00eda a los comandos, la pala funcionaba correctamente y el dise\u00f1o era estable. Sin embargo, durante el evento surgieron algunos inconvenientes:</p> <p>Uno de los motores se desprendi\u00f3 tras un choque con una silla. El control Bluetooth presentaba cierto retraso en la respuesta. Los movimientos eran algo bruscos, lo que dificultaba la precisi\u00f3n.</p> <p>A pesar de estos detalles, el coche cumpli\u00f3 con los objetivos t\u00e9cnicos del proyecto.</p>"},{"location":"#evidencias","title":"Evidencias","text":"<p>Ver la primera prueba del coche en YouTube</p>"},{"location":"#un-poco-del-partido","title":"Un poco del partido","text":"<p>Ver un poco de la competencia en Youtube</p>"},{"location":"#reflexiones-finales","title":"Reflexiones Finales","text":"<p>El proyecto fue una excelente oportunidad para aplicar conocimientos te\u00f3ricos en un entorno pr\u00e1ctico. Se logr\u00f3 integrar electr\u00f3nica, mec\u00e1nica y programaci\u00f3n en un sistema funcional. Algunas \u00e1reas de mejora identificadas fueron:</p> <p>Realizar m\u00e1s pruebas antes de la competencia Mejorar el montaje de los motores Optimizar el control desde la app</p> <p>Esta experiencia reforz\u00f3 la importancia de la planificaci\u00f3n, el trabajo colaborativo y la iteraci\u00f3n constante para lograr un producto funcional y competitivo.</p>"},{"location":"#codigo-para-controlar-el-coche","title":"Codigo para controlar el coche","text":"<pre><code>#include \"BluetoothSerial.h\"\n\nBluetoothSerial SerialBT;\n\n\n// Pines del puente H\n\nconst int IN1 = 12; // Motor izquierdo\n\nconst int IN2 = 11;\n\nconst int ENA = 13;\n\nconst int IN3 = 10; // Motor derecho\n\nconst int IN4 = 9;\n\nconst int ENB = 7;\n\nint valSpeed = 255;\n\n\nvoid setup() {\n\n  Serial.begin(115200);\n\n  SerialBT.begin(\"CarroESP32\"); // Nombre del dispositivo Bluetooth\n\n  pinMode(IN1, OUTPUT);\n\n  pinMode(IN2, OUTPUT);\n\n  pinMode(ENA, OUTPUT);\n\n  pinMode(IN3, OUTPUT);\n\n  pinMode(IN4, OUTPUT);\n\n  pinMode(ENB, OUTPUT);\n\n  stopMotors();\n\n}\n\n\nvoid loop() {\n\n  if (SerialBT.available()) {\n\n    char command = SerialBT.read();\n\n    Serial.println(command);\n\n    switch (command) {\n\n      case 'F': forward(); break;\n\n      case 'B': backward(); break;\n\n      case 'L': turnLeft(); break;\n\n      case 'R': turnRight(); break;\n\n      case 'S': stopMotors(); break;\n\n      case '0': setSpeed(0); break;\n\n      case '1': setSpeed(25); break;\n\n      case '2': setSpeed(50); break;\n\n      case '3': setSpeed(75); break;\n\n      case '4': setSpeed(100); break;\n\n      case '5': setSpeed(125); break;\n\n      case '6': setSpeed(150); break;\n\n      case '7': setSpeed(175); break;\n\n      case '8': setSpeed(200); break;\n\n      case '9': setSpeed(255); break;\n\n    }\n\n  }\n\n}\n\n\nvoid forward() {\n\n  analogWrite(ENA, valSpeed);\n\n  analogWrite(ENB, valSpeed);\n\n  digitalWrite(IN1, HIGH);\n\n  digitalWrite(IN2, LOW);\n\n  digitalWrite(IN3, HIGH);\n\n  digitalWrite(IN4, LOW);\n\n}\n\n\nvoid backward() {\n\n  analogWrite(ENA, valSpeed);\n\n  analogWrite(ENB, valSpeed);\n\n  digitalWrite(IN1, LOW);\n\n  digitalWrite(IN2, HIGH);\n\n  digitalWrite(IN3, LOW);\n\n  digitalWrite(IN4, HIGH);\n\n}\n\n\nvoid turnLeft() {\n\n  analogWrite(ENA, valSpeed / 2);\n\n  analogWrite(ENB, valSpeed);\n\n  digitalWrite(IN1, HIGH);\n\n  digitalWrite(IN2, LOW);\n\n  digitalWrite(IN3, HIGH);\n\n  digitalWrite(IN4, LOW);\n\n}\n\n\nvoid turnRight() {\n\n  analogWrite(ENA, valSpeed);\n\n  analogWrite(ENB, valSpeed / 2);\n\n  digitalWrite(IN1, HIGH);\n\n  digitalWrite(IN2, LOW);\n\n  digitalWrite(IN3, HIGH);\n\n  digitalWrite(IN4, LOW);\n\n}\n\n\nvoid stopMotors() {\n\n  analogWrite(ENA, 0);\n\n  analogWrite(ENB, 0);\n\n  digitalWrite(IN1, LOW);\n\n  digitalWrite(IN2, LOW);\n\n  digitalWrite(IN3, LOW);\n\n  digitalWrite(IN4, LOW);\n\n}\n\n\nvoid setSpeed(int val) {\n\n  valSpeed = val;\n\n}\n</code></pre>"},{"location":"Trabajo%203/","title":"Control de Giro, Velocidad y Posici\u00f3n con ESP32","text":""},{"location":"Trabajo%203/#proposito","title":"Proposito","text":"<p>Explorar el control de motores mediante el ESP32, aplicando t\u00e9cnicas de cambio de giro, variaci\u00f3n de velocidad con PWM y posicionamiento de servo motores.</p>"},{"location":"Trabajo%203/#meta-de-la-practica","title":"Meta de la practica","text":"<p>Comprender c\u00f3mo controlar motores DC y servos utilizando programaci\u00f3n en ESP32, aplicando conceptos de l\u00f3gica digital, modulaci\u00f3n por ancho de pulso (PWM) y mapeo de valores para posicionamiento.</p>"},{"location":"Trabajo%203/#organizacion-del-equipo","title":"Organizaci\u00f3n del Equipo","text":"<p>El equipo se dividi\u00f3 en dos \u00e1reas principales: desarrollo del codigo de programacion y desarrollo electr\u00f3nico.</p>"},{"location":"Trabajo%203/#materiales-utilizados","title":"Materiales Utilizados","text":"<ul> <li>ESP32</li> <li>Motor DC</li> <li>Servo motor</li> <li>Protoboard</li> <li>Cables de conexi\u00f3n (jumpers)</li> <li>Fuente de alimentaci\u00f3n</li> <li>Cable USB para cargar el programa</li> </ul>"},{"location":"Trabajo%203/#tecnologias-utilizadas","title":"Tecnolog\u00edas Utilizadas","text":"<ul> <li>Lenguajes: <code>Python</code></li> <li>Hardware: <code>ESP32</code>, <code>Arduino</code></li> <li>Software: <code>ARDUINO IDE</code> </li> </ul>"},{"location":"Trabajo%203/#sistema-electronico","title":"Sistema Electr\u00f3nico","text":"<p>Cambio de giro del motor DC: Se conectaron dos pines digitales al motor, alternando su estado para cambiar la direcci\u00f3n de giro (adelante y atr\u00e1s).</p> <p>Control de velocidad del motor DC: Se utiliz\u00f3 un pin PWM configurado para incrementar la velocidad del motor.</p> <p>Control de posici\u00f3n de un servo motor: Se configur\u00f3 un canal PWM con frecuencia de 50 Hz y resoluci\u00f3n de 12 bits. Se us\u00f3 la funci\u00f3n map() para convertir grados (0\u00b0 a 180\u00b0) en valores de duty cycle entre 205 y 410, que corresponden al rango de operaci\u00f3n del servo.</p>"},{"location":"Trabajo%203/#programacion","title":"Programaci\u00f3n","text":"<p>Cambio de giro: alterna los pines in1 e in2 para cambiar la direcci\u00f3n del motor. Velocidad progresiva: usa ledcWrite() para aumentar gradualmente la velocidad del motor en pasos del 20%. Servo motor: utiliza PWM de 12 bits para mover el servo a posiciones espec\u00edficas (0\u00b0, 90\u00b0, 180\u00b0), mostrando los valores en el monitor serial.</p>"},{"location":"Trabajo%203/#resultados-y-observaciones","title":"Resultados y Observaciones","text":"<p>El motor DC respondi\u00f3 correctamente al cambio de giro, alternando entre avance y retroceso. El control de velocidad fue progresivo y estable, mostrando c\u00f3mo el PWM puede modificar la potencia entregada al motor. El servo motor se posicion\u00f3 con precisi\u00f3n en los \u00e1ngulos programados, y los valores de duty cycle se reflejaron correctamente en el monitor serial. No se presentaron errores de conexi\u00f3n ni fallas en la ejecuci\u00f3n de los c\u00f3digos.</p>"},{"location":"Trabajo%203/#evidencias","title":"Evidencias","text":"<p>Ver en YouTube</p>"},{"location":"Trabajo%203/#reflexiones-finales","title":"Reflexiones Finales","text":"<p>Esta pr\u00e1ctica permiti\u00f3 comprender tres aspectos fundamentales del control de motores con ESP32: direcci\u00f3n, velocidad y posici\u00f3n. Se reforz\u00f3 el uso de PWM en diferentes resoluciones y frecuencias, y se evidenci\u00f3 c\u00f3mo la programaci\u00f3n puede traducirse en movimientos f\u00edsicos precisos. Adem\u00e1s, se aprendi\u00f3 a mapear valores para controlar servos, y se observ\u00f3 la importancia de los retardos (delay) para estabilizar los cambios.</p>"},{"location":"Trabajo%203/#codigo-direccion-basica","title":"Codigo Direccion Basica","text":"<pre><code>/*Control de 1 solo motor*/\n#define in1 27\n#define in2 14\n\nvoid setup() {\n  /*Declarar Pines Como salida*/\n  pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n}\n\nvoid loop() {\n  /*ADELANTE*/\n  digitalWrite(in1, 0);\n  digitalWrite(in2, 1);\n  delay(1000);\n  /*ALTO*/\n  digitalWrite(in1, 0);\n  digitalWrite(in2, 0);\n  delay(1000);\n  /*ATRAS*/\n  digitalWrite(in1, 1);\n  digitalWrite(in2, 0);\n  delay(1000);\n  /*ALTO*/\n  digitalWrite(in1, 0);\n  digitalWrite(in2, 0);\n  delay(1000);\n}\n</code></pre>"},{"location":"Trabajo%203/#codigo-control-de-velocidad","title":"Codigo Control de velocidad","text":"<pre><code>/*Control de 1 solo motor*/\n#define in1 27\n#define in2 14\n\nvoid setup() {\n  /*Declarar Pines Como salida*/\n  pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n}\n\nvoid loop() {\n  /*ADELANTE*/\n  digitalWrite(in1, 0);\n  digitalWrite(in2, 1);\n  delay(1000);\n  /*ALTO*/\n  digitalWrite(in1, 0);\n  digitalWrite(in2, 0);\n  delay(1000);\n  /*ATRAS*/\n  digitalWrite(in1, 1);\n  digitalWrite(in2, 0);\n  delay(1000);\n  /*ALTO*/\n  digitalWrite(in1, 0);\n  digitalWrite(in2, 0);\n  delay(1000);\n}\n</code></pre>"},{"location":"Trabajo%203/#codigo-control-de-servo","title":"Codigo Control de Servo","text":"<pre><code>/*Control de 1 solo motor*/\n#define pwm 12 //Definicion de pin de Velocidad\nint duty = 0;\nint grados = 0;\nvoid setup() {\n  /*Declarar Pines Como salida*/\n  pinMode(in1, OUTPUT);\n  pinMode(in2, OUTPUT);\n  /*Configuracion de pin PWM \n    - Se conecta al pin 12(pwm)\n    - Frecuencia de 50hz\n    - Resolucion de 12 bit (0-4096)\n    - Canal 0\n  */\n  ledcAttachChannel(pwm, 50, 12, 0);\n  Serial.begin(115200);\n}\n\nvoid loop() { \n  /*\n  Servo trabaja del ~5% al ~10% del total\n  ~5% - 0\u00b0\n  ~10% - 180\u00b0\n  5% de 4096 = 204.8\n  10% de 4096 = 409.6\n  */\n  grados=0;\n  duty= map(grados, 0, 180, 205, 410);\n  Serial.print(\"Pos: \");\n  Serial.println(duty);\n  ledcWrite(pwm, duty);\n  delay(1000);\n  grados=90;\n  duty= map(grados, 0, 180, 205, 410);\n  Serial.print(\"Pos: \");\n  Serial.println(duty);\n  ledcWrite(pwm, duty);\n  delay(1000);\n  grados=180;\n  duty= map(grados, 0, 180, 205, 410);\n  Serial.print(\"Pos: \");\n  Serial.println(duty);\n  ledcWrite(pwm, duty);\n  delay(1000);\n}\n</code></pre>"},{"location":"Trabajo2/","title":"Comunicaci\u00f3n Bluetooth entre ESP32 y Celular","text":""},{"location":"Trabajo2/#proposito","title":"Proposito","text":"<p>Establecer una comunicaci\u00f3n inal\u00e1mbrica entre un ESP32 y un tel\u00e9fono celular mediante Bluetooth, para enviar mensajes desde la app de Arduino y visualizar el texto recibido en el monitor serial de la computadora.</p>"},{"location":"Trabajo2/#meta-de-la-practica","title":"Meta de la practica","text":"<p>Establecer una comunicaci\u00f3n inal\u00e1mbrica entre el ESP32 y un celular mediante Bluetooth, para recibir mensajes escritos desde una app m\u00f3vil y mostrarlos en el monitor serial de la computadora.</p>"},{"location":"Trabajo2/#organizacion-del-equipo","title":"Organizaci\u00f3n del Equipo","text":"<p>El equipo se dividi\u00f3 en dos \u00e1reas principales: desarrollo del codigo de programacion y desarrollo electr\u00f3nico.</p>"},{"location":"Trabajo2/#materiales-utilizados","title":"Materiales Utilizados","text":"<ul> <li>ESP32</li> <li>Protoboard</li> <li>Cables de conexi\u00f3n (jumpers)</li> <li>Cable USB para cargar el programa</li> <li>Aplicaci\u00f3n Arduino Bluetooth Controller (en celular Android)</li> <li>Computadora con Arduino IDE</li> </ul>"},{"location":"Trabajo2/#tecnologias-utilizadas","title":"Tecnolog\u00edas Utilizadas","text":"<ul> <li>Lenguajes: <code>Python</code></li> <li>Hardware: <code>ESP32</code>, <code>Arduino</code></li> <li>Software: <code>ARDUINO IDE</code> </li> </ul>"},{"location":"Trabajo2/#sistema-electronico","title":"Sistema Electr\u00f3nico","text":"<p>El ESP32 se conect\u00f3 a la computadora mediante USB. No se utilizaron componentes externos como sensores o actuadores, ya que el enfoque fue exclusivamente en la comunicaci\u00f3n serial por Bluetooth. El ESP32 se configur\u00f3 como servidor Bluetooth para que el celular pudiera detectarlo y conectarse.</p>"},{"location":"Trabajo2/#programacion","title":"Programaci\u00f3n","text":"<p>El c\u00f3digo desarrollado en esta pr\u00e1ctica permite establecer una comunicaci\u00f3n inal\u00e1mbrica entre un ESP32 y un tel\u00e9fono celular mediante Bluetooth. El objetivo es que los mensajes escritos desde la app del celular se reciban en el ESP32 y se muestren en el monitor serial de la computadora.</p> <p>Primero, se incluye la librer\u00eda BluetoothSerial.h, que es necesaria para habilitar la comunicaci\u00f3n Bluetooth en el ESP32.  Luego, se crea un objeto llamado SerialBT, el cual se encargar\u00e1 de manejar la conexi\u00f3n Bluetooth.</p> <p>En la funci\u00f3n setup(), se inicializa la comunicaci\u00f3n serial con la computadora usando Serial.begin(115200), lo que permite visualizar los datos en el monitor serial del Arduino IDE. </p> <p>Despu\u00e9s, se inicia el Bluetooth con SerialBT.begin(\"ESP32A\u00d1\"), donde \"ESP32A\u00d1\" es el nombre que aparecer\u00e1 en el celular al buscar dispositivos Bluetooth. Finalmente, se imprime un mensaje indicando que el Bluetooth est\u00e1 listo para recibir conexiones.</p> <p>En la funci\u00f3n loop(), el programa verifica constantemente si hay datos disponibles desde el celular con SerialBT.available(). </p> <p>Si se detecta un mensaje, se lee con SerialBT.readString() y se muestra en el monitor serial usando Serial.println(). </p> <p>Esto permite ver en tiempo real lo que se escribe en la app del celular directamente en la pantalla de la computadora. Se incluye un peque\u00f1o retraso de 1 segundo (delay(1000)) para evitar que el ciclo se ejecute demasiado r\u00e1pido.</p> <p>Este c\u00f3digo demuestra c\u00f3mo se puede usar el ESP32 como receptor Bluetooth para recibir texto desde un dispositivo m\u00f3vil y visualizarlo en la computadora, lo cual es \u00fatil para proyectos de comunicaci\u00f3n, monitoreo o control remoto.</p>"},{"location":"Trabajo2/#resultados-y-observaciones","title":"Resultados y Observaciones","text":"<p>La conexi\u00f3n Bluetooth fue exitosa y estable. Los mensajes escritos desde el celular se reflejaban correctamente en el monitor serial. El ESP32 respondi\u00f3 de forma inmediata a los datos recibidos. No se presentaron errores de transmisi\u00f3n ni desconexiones durante la prueba.</p>"},{"location":"Trabajo2/#evidencias","title":"Evidencias","text":"<p>Ver en YouTube</p>"},{"location":"Trabajo2/#reflexiones-finales","title":"Reflexiones Finales","text":"<p>Esta pr\u00e1ctica permiti\u00f3 entender c\u00f3mo se establece una comunicaci\u00f3n serial inal\u00e1mbrica entre un microcontrolador y un dispositivo m\u00f3vil. Se reforz\u00f3 el uso de librer\u00edas espec\u00edficas como BluetoothSerial y la importancia de configurar correctamente la velocidad de transmisi\u00f3n. Fue \u00fatil para visualizar c\u00f3mo los datos enviados desde una app pueden ser procesados en tiempo real por el ESP32 y mostrados en la computadora.</p>"},{"location":"Trabajo2/#codigo","title":"Codigo","text":"<pre><code>#include \"BluetoothSerial.h\"   \n\nBluetoothSerial SerialBT;      \nvoid setup() {\n  Serial.begin(115200);       \n  SerialBT.begin(\"ESP32A\u00d1\");   \n  Serial.println(\"Bluetooth listo. Esperando conexi\u00f3n...\");\n}\n\nvoid loop() {\n  if (SerialBT.available()) {                \n    String mensaje = SerialBT.readString();  \n    Serial.println(\"Recibido: \" + mensaje);  \n  delay(1000);  \n}\n</code></pre>"},{"location":"aa/","title":"Encendido de LED con Pulsador usando Arduino","text":""},{"location":"aa/#proposito","title":"Proposito","text":"<p>El objetivo principal de esta pr\u00e1ctica fue comprender el funcionamiento b\u00e1sico de entradas y salidas digitales en Arduino. Se busc\u00f3 controlar el encendido de un LED utilizando un bot\u00f3n f\u00edsico conectado a una protoboard, aplicando conceptos fundamentales de electr\u00f3nica como resistencias pull-down y l\u00f3gica de control.</p>"},{"location":"aa/#meta-de-la-practica","title":"Meta de la practica","text":"<p>Comprender el funcionamiento de entradas digitales en Arduino y aplicar este conocimiento para controlar un LED mediante un pulsador f\u00edsico.</p>"},{"location":"aa/#organizacion-del-equipo","title":"Organizaci\u00f3n del Equipo","text":"<p>El equipo se dividi\u00f3 en dos \u00e1reas principales: desarrollo del codigo de programacion y desarrollo electr\u00f3nico.</p>"},{"location":"aa/#materiales-utilizados","title":"Materiales Utilizados","text":"<ul> <li>Arduino UNO</li> <li>Protoboard </li> <li>LED rojo </li> <li>Resistencia de 220\u03a9 (limitadora para el LED)  </li> <li>Resistencia de 10k\u03a9 (pull-down para el bot\u00f3n)  </li> <li>Pulsador (bot\u00f3n) </li> <li>Cables de conexi\u00f3n (jumpers) </li> <li>Cable USB para cargar el programa</li> </ul>"},{"location":"aa/#tecnologias-utilizadas","title":"Tecnolog\u00edas Utilizadas","text":"<ul> <li>Lenguajes: <code>Python</code></li> <li>Hardware: <code>ESP32</code>, <code>Arduino</code></li> <li>Software: <code>ARDUINO IDE</code> </li> </ul>"},{"location":"aa/#sistema-electronico","title":"Sistema Electr\u00f3nico","text":"<p>El circuito se arm\u00f3 sobre una protoboard. El LED se conect\u00f3 al pin digital 13 del Arduino, con una resistencia de 220\u03a9 en serie para evitar sobrecorriente. El bot\u00f3n se conect\u00f3 al pin digital 2, acompa\u00f1ado de una resistencia de 10k\u03a9 como pull-down para asegurar que el estado del pin sea bajo cuando el bot\u00f3n no est\u00e1 presionado. La l\u00f3gica del circuito es simple: al presionar el bot\u00f3n, el pin digital lee un estado alto (HIGH) y enciende el LED; al soltarlo, el estado vuelve a bajo (LOW) y el LED se apaga.</p>"},{"location":"aa/#programacion","title":"Programaci\u00f3n","text":"<p>El c\u00f3digo fue escrito en Arduino IDE y se basa en la lectura del estado del bot\u00f3n para controlar el LED, el codigo se desarrollo en base y apoyo del codigo proporcionado por Oliver.</p>"},{"location":"aa/#resultados-y-observaciones","title":"Resultados y Observaciones","text":"<p>El circuito respondi\u00f3 correctamente al presionar el bot\u00f3n, encendiendo el LED de forma inmediata. Se comprob\u00f3 que la resistencia pull-down evit\u00f3 lecturas err\u00e1ticas cuando el bot\u00f3n no estaba presionado. La pr\u00e1ctica permiti\u00f3 verificar el funcionamiento b\u00e1sico de entradas y salidas digitales en Arduino, y se logr\u00f3 una interacci\u00f3n estable entre hardware y software</p>"},{"location":"aa/#evidencias","title":"Evidencias","text":"<p>Ver en YouTube</p>"},{"location":"aa/#reflexiones-finales","title":"Reflexiones Finales","text":"<p>Esta pr\u00e1ctica fue una excelente introducci\u00f3n al uso de microcontroladores. Se logr\u00f3 entender c\u00f3mo interact\u00faan los componentes electr\u00f3nicos b\u00e1sicos con el Arduino y c\u00f3mo la programaci\u00f3n puede controlar el comportamiento f\u00edsico de un sistema. Se aprendi\u00f3 la importancia de las resistencias pull-down para evitar lecturas err\u00e1ticas, y se reforz\u00f3 el concepto de entradas y salidas digitales. Adem\u00e1s, se comprob\u00f3 que incluso con un circuito sencillo se pueden lograr interacciones \u00fatiles entre hardware y software.</p>"},{"location":"aa/#codigo","title":"Codigo","text":"<pre><code>const int led=27;\nconst int button=32;\n\nvoid setup() {\n  Serial.begin(115200); //INICIO LA COMUNICACION EN 115200 char por segundo\n  pinMode(led,OUTPUT);\n  pinMode(button,INPUT);\n}\n\nvoid loop() {\n  int estado = digitalRead(button);\n  if(estado == 1){\n    digitalWrite(led,1);\n  }\n  else{\n    digitalWrite(led,0);\n\u00a0\u00a0}\n}\n</code></pre>"},{"location":"about/","title":"\u00bfQuien soy?","text":"<p>Mi nombre es Erik y actualmente estoy estudiando Ingenieria Mecatronica en la Ibero Puebla.</p> <p>En esta pagina resumire todos los proyectos que realice, con el fin de compartir mis conocimientos y aportes a la Mecatronica.</p>"},{"location":"about/#intereses-y-areas-de-enfoque","title":"Intereses y Areas de enfoque:","text":"<ul> <li>Me gusta aprender mucho todo lo que tiene que ver con informatica, tecnologia, innovacion y todo ello.</li> <li>Me gusta la intregacion de objetos que usamos en la vida cotidiana a la tecnologia.</li> <li>Me enfoco en los programas de modelado de piezas 3D</li> </ul>"},{"location":"about/#mis-aptitudes-son","title":"Mis aptitudes son:","text":"<ul> <li>Trabajo eficiente </li> <li>Resolucion de problemas </li> <li>Trabajo en equipo </li> <li>Facilidad de aprendizaje</li> </ul>"},{"location":"about/#de-que-me-siento-orgulloso","title":"\u00bfDe que me siento orgulloso?","text":"<p>En mi trayectoria por la preparatoria estuve involucrado en todo tipo de proyectos, buscando que estos me ense\u00f1aran algo y que me divirtiesen. Me siento realmente orgulloso de haber sido parte de todo lo que fue eventos escolares fuertes, participe como produccion ejecutiva en la obra escolar que es una obra de primer nivel, presidente de logistica en la Sociedad de Alumnos de mi preparatoria, rol importante en el equipo representativo de Basquetbol siendo seleccionado para las competencias estatales entre colegios jesuitas en 2024 y 2025.</p> <p>Erik Andr\u00e9 Zepeda Tapia | contacto: 204440@iberopuebla.mx </p> <p></p>"}]}